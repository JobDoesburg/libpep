# `libpep`: Library for polymorphic pseudonymization and encryption

This library implements the PEP encryption based on ElGamal, and operations on these encrypted messages.
A message `M` can be encrypted for a receiver which has public key `Y` associated with it, belonging to secret key `y`. 
This encryption is random: every time a different random `r` is used, resulting in different ciphertexts (encrypted messages).
We represent this encryption function as `EG(r, M, Y)`.

The library supports three operations on ciphertext `in` (= `EG(r, M, Y)`, encrypting message `M` for public key `Y` with random `r`):
- `out = rekey(in, k)`: if `in` can be decrypted by secret key `y`, then `out` can be decrypted by secret key `k*y`.
   Decryption will both result in message `M`. Spec: `in = EG(r, M, Y)` is transformed to `out = EG(r, M, k*Y)`.
- `out = reshuffle(in, n)`: modifies a ciphertext `in` (an encrypted form of `M`), so that after decryption of `out` the decrypted message will be equal to `n*M`.
  Spec: `in = EG(r, M, Y)` is transformed to `out = EG(r, n*M, Y)`.
- `out = rerandomize(in, s)`: scrambles a ciphertext.
  Both `in` and `out` can be decrypted by the same secret key `y`, both resulting in the same decrypted message `M`.
  However, the binary form of `in` and `out` differs. Spec: `in = EG(r, M, Y)` is transformed to `out = EG(r+s, M, Y)`;

The `reshuffle(in, n)` and `rekey(in, k)` can be combined in a slightly more efficient `rsk(in, k, n)`.

Additionally, `reshuffle_from_to(in, n_from, n_to)` and `rekey_from_to(in, k_from, k_to)`, as well as `rsk_from_to(...)`, can be used for bidirectional transformations between two keys, effectively applying `k = k_from^-1 * k_to` and `n = n_from^-1 * n_to`.

There are also zero knowledge proof version of these operations.
These are needed so that a party can prove to another party that it has consistently applied the operation on the input data with a specific secret factor, without revealing that factor (but only a public 'verifier' value related to that secret factor).
When distributing trust over multiple central servers, these zero knowledge proofs are essential, so that a malfunctioning server can not violate security guarantees of the system.

The key idea behind this form of cryptography is that the pseudonymization and rekeying operations are applied on *encrypted* data.
This means that during initial encryption, the ultimate receiver(s) do(es) not yet need to be known.
Data can initially be encrypted for one key, and later rekeyed and potentially reshuffled (in case of identifiers) for another key, leading to asynchronous end-to-end encryption with built-in pseudonymisation.

Apart from a Rust crate, this library also contains a WASM library for usage in the browser or web applications, enabled with the `wasm` feature.

## Applications

For pseudonymization, the core operation is *reshuffle* with `n`.
It modifies a main pseudonym with a factor `n` that is specific to a user (or user group) receiving the pseudonym.
After applying a user specific factor `n`, a pseudonym is called a *local pseudonym*.
The factor `n` is typically tied to the *access group* or *domain of a user*.

Using only a reshuffle is insufficient, as the pseudonym is still encrypted with the public key `Y` (which can be decrypted by the secret key `y`).
To allow a user to decrypt the encrypted pseudonym, a *rekey* with `k` is needed, in combination with a protocol to hand the user the secret key `k*y`.
The factor `k` is typically tied to the *current session of a user*.

To make pseudonyms harder to trace, rerandomize is applied frequently.
This way a binary compare of the encrypted pseudonym will not leak any information.

## Implementation

This library is using the Ristretto encoding on Curve25519, implemented in the [`curve25519-dalek` crate](https://docs.rs/curve25519-dalek/latest/curve25519_dalek/).
There are a number of arithmetic rules for scalars and group elements: group elements can be added and subtracted from each other.
Scalars support addition, subtraction, and multiplication.
Division can be done by multiplying with the inverse (using `s.invert()` for non-zero scalar `s`).
A scalar can be converted to a group element (by multiplying with the special generator `G`), but not the other way around.
Group elements can also be multiplied by a scalar.

Group elements have an *almost* 32 byte range (top bit is always zero, and some other values are invalid).
Therefore, not all AES-256 keys (using the full 32 bytes range) are valid group elements.
But all group elements are valid AES-256 keys.
Group elements can be generated by `GroupElement::random(..)` or `GroupElement::from_hash(..)`.
Scalars are also 32 bytes, and can be generated with `Scalar::random(..)` or `Scalar::from_hash(..)`.

The zero knowledge proofs are offline Schnorr proofs, based on a Fiat-Shamir transform.
The hashing algorithm used is SHA512.

## API

We offer APIs at different abstraction levels.

0. The `arithmetic` module offers the basic arithmetic operations on scalars and group elements, the `elgamal` module offers the ElGamal encryption and decryption operations and the `zkps` module offers basic zero knowledge proofs and signature operations.
1. The `primitives` module implements the basic PEP operations such as `rekey`, `reshuffle`, and `rerandomize`, and the `proved` module offers the same operations with zero knowledge proofs.
2. The `high_level` and `high_level_proved` modules offer a more user-friendly API with many high level data types such as `Pseudonyms` and `DataPoints`.
3. The `distributed` modules additionally provides a high-level API for distributed scenarios, where multiple servers are involved in the rekeying and reshuffling operations and keys are derived from multiple master keys.

Depending on the use case, you can choose the appropriate level of abstraction.

## Building and running

Build using cargo: `cargo build` and test using `cargo test`.

To build the WASM library, use either `npm run build:nodejs` or `npm run build:web` (which will call `wasm-pack build --features wasm` for the preferred target).

The wasm library can be tested using the Node.js `jest` framework, after compiling the wasm library for Node.js: `npm run test`.

## Install

Install using
```
cargo install libpep
```

## License
- Authors: Bernard van Gastel and Job Doesburg
- License: Apache License 2.0

## Background

Based on the article by Eric Verheul and Bart Jacobs, *Polymorphic Encryption and Pseudonymisation in Identity Management and Medical Research*. In **Nieuw Archief voor Wiskunde (NAW)**, 5/18, nr. 3, 2017, p. 168-172.
This article does not contain the zero knowledge proofs.
