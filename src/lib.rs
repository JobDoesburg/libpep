//! This library implements the PEP encryption based on ElGamal, and operations on these encrypted messages. A message [GroupElement] `M` can be encrypted for a receiver which has public key [GroupElement] `Y` associated with it, belonging to secret key [ScalarNonZero] `y`. This encryption is random: a different random [ScalarNonZero] `r` can be used during encryption for a specific public key, resulting in different ciphertexts (encrypted messages) but decryptable by only knowing the secret key. We represent this encryption function as `EG(r, M, Y)`, which is implemented in Rust as [encrypt]. Encrypted messages `msg` are often pseudonyms or AES keys (see below).
//!
//! [ElGamal] ciphertext on which the three PEP operations can be performed:
//! - [rerandomize] by [ScalarNonZero] `s`: change encrypted representation, same contents when decrypted;
//! - [reshuffle] by [ScalarNonZero] `n`: change encrypted representation so that is has different contents when decrypted equal to `n*msg`, if the original encrypted message was [GroupElement] `msg`.
//! - [rekey] by [ScalarNonZero] `k`: change encrypted representation, so it can be decrypted by a different key `k*y` if the input can be decrypted by [ScalarNonZero] `y`.
//!
//! There are also zero knowledge proof version of these operations in module [zkp]. These are needed so that a party can prove to another party that it has applied the operation on the input data, without revealing the factors used in the operation.
//!
//! When distributing trust over multiple central servers, these zero knowledge proofs are essential, so that a malfunctioning server can not violate security guarantees of the system. For example, if reshuffling by `n` a pseudonym on a server, the requestor wants to make sure that the sent over pseudonym is actually reshuffled using the correct factor `n`, instead of a random other pseudonym or a different factor.
//!
//! Same library in different languages:
//! - [libpep-cpp](https://github.com/bvgastel/libpep-cpp) (C++);
//! - [libpep on crates.io](https://crates.io/crates/libpep) (Rust).
//!
//! ## Applications
//!
//! For **pseudonimisation**, the core operation is [reshuffle] with `n`. It modifies a main pseudonym with a factor `n` that is specific to a user (or user group) receiving the pseudonym. After applying a user specific factor `n`, a pseudonym is called a *local pseudonym*. The factor `n` is typically tied to the *access group of a user*.
//! 
//! Using only a reshuffle is insufficient, as the pseudonym is still encrypted with the public key `Y` (which can be decrypted by the secret key `y`). To allow a user to decrypt the encrypted pseudonym, a [rekey] with `k` is needed, in combination with a protocol to hand the user the secret key `k*y`. The factor `k` is typically tied to the *current session of a user*.
//!
//! To make pseudonyms harder to trace, [rerandomize] is applied frequently. This way a binary compare of the encrypted pseudonym will not leak any information.
//!
//! For **data protection**, the [rekey] operation described above allows a [GroupElement] `msg` to be
//! decryptable with another key but decryption results in the same original GroupElement `msg`. This GroupElement
//! can be used as an AES key to encrypt a larger message. Care must be taken that such an AES key is
//! not functioning as a defacto global identifier.
//!
//! ## Implementation
//!
//! This library is using the Ristretto encoding on Curve25519, implemented in the curve25519-dalek crate. There are a number of arithmetic rules for scalars and group elements: group elements can be added and subtracted from each other. Scalars support addition, subtraction, and multiplication. Division can be done by multipling with the inverse (using `s.invert()` for non-zero scalar `s`). A scalar can be converted to a group element (by multiplying with the special generator `G`), but not the other way around. Group elements can also be multiplied by a scalar.
//! 
//! Group elements have an *almost* 32 byte range (top bit is always zero, and some other values are invalid). Therefore, not all AES-256 keys (using the full 32 bytes range) are valid group elements. But all group elements are valid AES-256 keys. Group elements can be generated by [GroupElement::random] or [GroupElement::from_hash]. Scalars are also 32 bytes, and can be generated with [ScalarNonZero::random] or [ScalarNonZero::from_hash].
//!
//! The zero knowledge proofs are offline Schnorr proofs, based on a Fiat-Shamir transform. The hashing algorithm used is SHA512.
use curve25519_dalek::ristretto::RistrettoPoint;
use curve25519_dalek::ristretto::CompressedRistretto;
use curve25519_dalek::traits::Identity;
extern crate rand_core;
extern crate sha2;
use rand::CryptoRng;
use rand::RngCore;
use sha2::{Sha512, Digest};

/// Constant so that a [ScalarNonZero]/[ScalarCanBeZero] s can be converted to a [GroupElement] by performing `s * G`.
const G: GroupElement = GroupElement(curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT);

/// Returned if a zero scalar is inverted (which is similar to why a division by zero is not
/// possible).
#[derive(Debug)]
pub struct ZeroArgumentError;

/// Element on a group. Can not be converted to a scalar. Supports addition and substraction. Multiplication by a scalar is supported.
#[derive(Copy,Clone,Eq,PartialEq,Debug)]
pub struct GroupElement(RistrettoPoint);

impl GroupElement {
    pub fn encode(&self) -> [u8; 32] {
        self.0.compress().0
    }

    pub fn decode_from_slice(v: &[u8]) -> Option<Self> {
        if v.len() != 32 {
            None
        } else {
            CompressedRistretto::from_slice(v).decompress().map(Self)
        }
    }

    pub fn decode(v: [u8; 32]) -> Option<Self> {
        CompressedRistretto(v).decompress().map(Self)
    }
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        Self(RistrettoPoint::random(rng))
    }
    pub fn from_hash(v: &[u8; 64]) -> Self {
        Self(RistrettoPoint::from_uniform_bytes(v))
    }

    pub fn identity() -> Self {
        Self(RistrettoPoint::identity())
    }
}

/// Scalar, always non-zero. Can be converted to a GroupElement. Supports multiplication, and inversion (so division is possible). For addition and substraction, use [ScalarCanBeZero].
#[derive(Copy,Clone,Eq,PartialEq,Debug)]
pub struct ScalarNonZero(curve25519_dalek::scalar::Scalar);

impl ScalarNonZero {
    /// Always return a non-zero scalar.
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        loop {
            let retval = curve25519_dalek::scalar::Scalar::random(rng);
            if !retval.as_bytes().iter().all(|x| *x == 0) {
                return Self(retval);
            }
        }
    }

    pub fn from_hash(v: &[u8; 64]) -> Self {
        let retval = curve25519_dalek::scalar::Scalar::from_bytes_mod_order_wide(v);
        if retval.as_bytes().iter().all(|x| *x == 0) {
            Self(curve25519_dalek::scalar::Scalar::one())
        } else {
            Self(retval)
        }
    }

    pub fn one() -> Self {
        Self(curve25519_dalek::scalar::Scalar::one())
    }

    pub fn invert(&self) -> Self {
        Self(self.0.invert())
    }
}

/// Scalar, can be zero. Can be converted to a GroupElement. Supports multiplication, inversion (so division is possible), addition and substraction.
#[derive(Copy,Clone,Eq,PartialEq,Debug)]
pub struct ScalarCanBeZero(curve25519_dalek::scalar::Scalar);

impl ScalarCanBeZero {
    pub fn decode_from_slice(v: &[u8]) -> Option<Self> {
        if v.len() != 32 {
            None
        } else {
            let mut tmp = [0u8; 32];
            tmp.copy_from_slice(v);
            curve25519_dalek::scalar::Scalar::from_canonical_bytes(tmp).map(Self)
        }
    }

    pub fn decode(v: [u8; 32]) -> Option<Self> {
        curve25519_dalek::scalar::Scalar::from_canonical_bytes(v).map(Self)
    }

    pub fn one() -> Self {
        Self(curve25519_dalek::scalar::Scalar::one())
    }

    pub fn zero() -> Self {
        Self(curve25519_dalek::scalar::Scalar::zero())
    }

    pub fn is_zero(&self) -> bool {
        self.0.as_bytes().iter().all(|x| *x == 0)
    }
}

impl From<ScalarNonZero> for ScalarCanBeZero {
    fn from(value: ScalarNonZero) -> Self {
        Self(value.0)
    }
}

impl TryFrom<ScalarCanBeZero> for ScalarNonZero {
    type Error = ZeroArgumentError;

    fn try_from(value: ScalarCanBeZero) -> Result<Self, Self::Error> {
        if value.is_zero() {
            Err(ZeroArgumentError)
        } else {
            Ok(Self(value.0))
        }
    }
}

pub trait ScalarTraits {
    fn encode(&self) -> [u8; 32] {
        let mut retval = [0u8; 32];
        retval[0..32].clone_from_slice(self.raw().as_bytes());
        retval
    }
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar;
}

impl ScalarTraits for ScalarCanBeZero {
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar {
        &self.0
    }
}

impl ScalarTraits for ScalarNonZero {
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar {
        &self.0
    }
}

impl<'a, 'b> std::ops::Add<&'b ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 + rhs.0)
    }
}
impl<'b> std::ops::Add<&'b ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(mut self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}
impl<'a> std::ops::Add<ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(self, mut rhs: ScalarCanBeZero) -> Self::Output {
        rhs.0 += self.0;
        rhs
    }
}
impl std::ops::Add<ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(mut self, rhs: ScalarCanBeZero) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Sub<&'b ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 - rhs.0)
    }
}
impl<'b> std::ops::Sub<&'b ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(mut self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}
impl<'a> std::ops::Sub<ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(self, rhs: ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 - rhs.0)
    }
}
impl std::ops::Sub<ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(mut self, rhs: Self) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Mul<&'b ScalarNonZero> for &'a ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(self, rhs: &'b ScalarNonZero) -> Self::Output {
        ScalarNonZero(self.0 * rhs.0)
    }
}
impl<'b> std::ops::Mul<&'b ScalarNonZero> for ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(mut self, rhs: &'b ScalarNonZero) -> Self::Output {
        self.0 *= rhs.0;
        self
    }
}
impl<'a> std::ops::Mul<ScalarNonZero> for &'a ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(self, mut rhs: ScalarNonZero) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl std::ops::Mul<ScalarNonZero> for ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(mut self, rhs: Self) -> Self::Output {
        self.0 *= rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Add<&'b GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn add(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 + rhs.0)
    }
}
impl<'b> std::ops::Add<&'b GroupElement> for GroupElement {
    type Output = GroupElement;

    fn add(mut self, rhs: &'b GroupElement) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}
impl<'a> std::ops::Add<GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn add(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 += self.0;
        rhs
    }
}
impl std::ops::Add<GroupElement> for GroupElement {
    type Output = GroupElement;

    fn add(mut self, rhs: Self) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Sub<&'b GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn sub(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 - rhs.0)
    }
}
impl<'b> std::ops::Sub<&'b GroupElement> for GroupElement {
    type Output = GroupElement;

    fn sub(mut self, rhs: &'b GroupElement) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}
impl<'a> std::ops::Sub<GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn sub(self, rhs: GroupElement) -> Self::Output {
        GroupElement(self.0 - rhs.0)
    }
}
impl std::ops::Sub<GroupElement> for GroupElement {
    type Output = GroupElement;

    fn sub(mut self, rhs: Self) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a,'b> std::ops::Mul<&'b GroupElement> for &'a ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'b> std::ops::Mul<&'b GroupElement> for ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'a> std::ops::Mul<GroupElement> for &'a ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl std::ops::Mul<GroupElement> for ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl<'a,'b> std::ops::Mul<&'b GroupElement> for &'a ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'b> std::ops::Mul<&'b GroupElement> for ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'a> std::ops::Mul<GroupElement> for &'a ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl std::ops::Mul<GroupElement> for ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}

/// ElGamal ciphertext on which the three PEP operations can be performed:
/// - [rerandomize]: change encrypted representation, same contents when decrypted;
/// - [reshuffle]: change encrypted representation, different contents when decrypted;
/// - [rekey]: change encrypted representation, can be decrypted by a different key.
#[derive(Debug,Eq,PartialEq)]
pub struct ElGamal {
  pub b: GroupElement,
  pub c: GroupElement,
  pub y: GroupElement,
}


impl ElGamal {
    pub fn encode(&self) -> [u8; 96] {
        let mut retval = [0u8; 96];
        retval[0..32].clone_from_slice(self.b.0.compress().as_bytes());
        retval[32..64].clone_from_slice(self.c.0.compress().as_bytes());
        retval[64..96].clone_from_slice(self.y.0.compress().as_bytes());
        retval
    }

    pub fn decode(v: &[u8]) -> Option<Self> {
        if v.len() != 96 {
            None
        } else {
            Some(Self {
                b: GroupElement::decode_from_slice(&v[0..32])?,
                c: GroupElement::decode_from_slice(&v[32..64])?,
                y: GroupElement::decode_from_slice(&v[64..96])?,
            })
        }
    }

    pub fn clone(&self) -> Self {
        Self {
            b: self.b,
            c: self.c,
            y: self.y,
        }
    }
}

/// Encrypt message [GroupElement] `msg` using public key [GroupElement] `public_key` to a ElGamal tuple.
pub fn encrypt<R: RngCore + CryptoRng>(msg: &GroupElement, public_key: &GroupElement, rng: &mut R) -> ElGamal {
    let r = ScalarNonZero::random(rng); // random() should never return a zero scalar
    debug_assert!(public_key != &GroupElement::identity()); // we should not encrypt anything with an empty public key, as this will result in plain text send over the line
    ElGamal {
        b: r*G,
        c: msg + r*public_key,
        y: *public_key
    }
}


/// Encrypt message [GroupElement] `msg` using randomized public key [GroupElement] `public_key` and the randomizer [GroupElement] `randomizer_g` to a ElGamal tuple. A randomized public key can be computed from a [GroupElement] public key `pk` by `randomizer*pk` using a random [ScalarNonZero] randomizer. The `randomizer` can be converted to the necessary [GroupElement] argument by doing `randomizer*G`.
pub fn encrypt_using_randomizer<R: RngCore + CryptoRng>(msg: &GroupElement, public_key: &GroupElement, randomizer_g: &GroupElement, rng: &mut R) -> ElGamal {
    debug_assert!(public_key != &GroupElement::identity()); // we should not encrypt anything with an empty public key, as this will result in plain text send over the line
    let r = ScalarNonZero::random(rng); // random() should never return a zero scalar
    ElGamal {
        b: r*G,
        c: msg + r*public_key + r*randomizer_g,
        y: *public_key
    }
}
/// Decrypt ElGamal tuple (encrypted using `secret_key * G`) using secret key [ScalarNonZero] `secret_key`.
pub fn decrypt(s: &ElGamal, secret_key: &ScalarNonZero) -> GroupElement {
    s.c - secret_key*s.b
}

/// Change encrypted representation using [ScalarNonZero] `s`, same contents when decrypted.
pub fn rerandomize(v: &ElGamal, s: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: s*G + v.b,
        c: s*v.y + v.c,
        y: v.y
    }
}

/// Change encrypted representation using [ScalarNonZero] `k`, so it can be decrypted by a different key `k*y` if the input can be decrypted by [ScalarNonZero] `y`.
pub fn rekey(v: &ElGamal, k: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: k.invert() * v.b,
        c: v.c,
        y: k * v.y,
    }
}

/// Change encrypted representation using [ScalarNonZero] `n` so that is has different contents when decrypted equal to `n*msg`, if the original encrypted message was [GroupElement] `msg`. 
pub fn reshuffle(v: &ElGamal, n: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: n * v.b,
        c: n * v.c,
        y: v.y
    }
}

/// Combination of `rekey(k)` and `reshuffle(n)`
pub fn rks(v: &ElGamal, k: &ScalarNonZero, n: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: (n * k.invert()) * v.b,
        c: n * v.c,
        y: k * v.y
    }
}

//////////////////////////

/// Zero-knowledge proofs useful for example if PEP is distributed across multiple hosts.
pub mod zkp {
use crate::*;

// Offline Schnorr proof using Fiat-Shamir transform.
// Proof that given a GroupElement `m` and a scalar `a`,
// member `n` is equal to `a*m`. This can be verified using
// this struct, the original `m` and `a*G`, so that the original
// scalar `a` remains secret.
pub struct Proof {
  pub n: GroupElement,
  pub c1: GroupElement,
  pub c2: GroupElement,
  pub s: ScalarCanBeZero,
}

impl std::ops::Deref for Proof {
    type Target = GroupElement;

    fn deref(&self) -> &Self::Target {
        &self.n
    }
}

// returns <A=a*G, Proof with a value N = a*M>
pub fn create_proof<R: RngCore + CryptoRng>(a: &ScalarNonZero /*secret*/, gm: &GroupElement /*public*/, rng: &mut R) -> (GroupElement,Proof) {
    let r = ScalarNonZero::random(rng);

    let ga = a*G;
    let gn = a*gm;
    let gc1 = r*G;
    let gc2 = r*gm;

    let mut hasher = Sha512::default();
    hasher.update(ga.encode());
    hasher.update(gm.encode());
    hasher.update(gn.0.compress().as_bytes());
    hasher.update(gc1.0.compress().as_bytes());
    hasher.update(gc2.0.compress().as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    let e = ScalarNonZero::from_hash(&bytes);
    let s = ScalarCanBeZero::from(a*e) + ScalarCanBeZero::from(r);
    (ga, Proof {n: gn, c1: gc1, c2: gc2, s})
}

#[must_use]
pub fn verify_proof_split(ga: &GroupElement, gm: &GroupElement, gn: &GroupElement, gc1: &GroupElement, gc2: &GroupElement, s: &ScalarCanBeZero) -> bool {
    let mut hasher = Sha512::default();
    hasher.update(ga.0.compress().as_bytes());
    hasher.update(gm.0.compress().as_bytes());
    hasher.update(gn.0.compress().as_bytes());
    hasher.update(gc1.0.compress().as_bytes());
    hasher.update(gc2.0.compress().as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    let e = ScalarNonZero::from_hash(&bytes);
    // FIXME: speed up with https://docs.rs/curve25519-dalek/latest/curve25519_dalek/traits/trait.VartimeMultiscalarMul.html
    // FIXME: check if a faster non-constant time equality can be used
    s*G == e*ga + gc1 && s*gm == e*gn + gc2
    // (a*e + r)*G = e*a*G + r*G
    // (a*e + r)*gm == e*a*gm + r*gm
}

#[must_use]
pub fn verify_proof(ga: &GroupElement, gm: &GroupElement, p: &Proof) -> bool {
    verify_proof_split(ga, gm, &p.n, &p.c1, &p.c2, &p.s)
}


pub struct ProofInv {
    pub ga_inv: GroupElement,
    pub gc: GroupElement,
    pub s: ScalarCanBeZero,
}

impl std::ops::Deref for ProofInv {
    type Target = GroupElement;

    fn deref(&self) -> &Self::Target {
        &self.ga_inv
    }
}

// returns <A=a*G, Proof with a value N = a^-1*M>
pub fn create_proof_inv<R: RngCore + CryptoRng>(a: &ScalarNonZero /*secret*/, rng: &mut R) -> (GroupElement, ProofInv) {
    let r = ScalarNonZero::random(rng);

    let ga = a * G;
    let ga_inv = a.invert() * G;
    let gc = r*G;

    let mut hasher = Sha512::default();
    hasher.update(ga.0.compress().as_bytes());
    hasher.update(ga_inv.0.compress().as_bytes());
    hasher.update(gc.0.compress().as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    let e = ScalarNonZero::from_hash(&bytes);
    let s = ScalarCanBeZero::from(a.invert() * e) + ScalarCanBeZero::from(r);
    (ga, ProofInv {ga_inv, gc, s})
}

#[must_use]
pub fn verify_proof_split_inv(ga: &GroupElement, ga_inv: &GroupElement, gc: &GroupElement, s: &ScalarCanBeZero) -> bool {
    let mut hasher = Sha512::default();
    hasher.update(ga.0.compress().as_bytes());
    hasher.update(ga_inv.0.compress().as_bytes());
    hasher.update(gc.0.compress().as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    let e = ScalarNonZero::from_hash(&bytes);

    debug_assert_eq!(s*G, e * ga_inv + gc);
    s*G == e * ga_inv + gc
}

#[must_use]
pub fn verify_proof_inv(ga: &GroupElement, p: &ProofInv) -> bool {
    verify_proof_split_inv(ga, &p.ga_inv, &p.gc, &p.s)
}

//// SIGNATURES

type Signature = Proof;

pub fn sign<R: RngCore + CryptoRng>(message: &GroupElement, secret_key: &ScalarNonZero, rng: &mut R) -> Signature {
    create_proof(secret_key, message, rng).1
}

#[must_use]
pub fn verify(message: &GroupElement, p: &Signature, public_key: &GroupElement) -> bool {
    verify_proof(public_key, message, p)
}

//// RERANDOMIZE

// We are re-using some variables from the Proof to reconstruct the Rerandomize operation.
// This way, we only need 1 Proof object (which are fairly large)
type ProvedRerandomize = (GroupElement,Proof);

pub fn prove_rerandomize<R: RngCore + CryptoRng>(v: &ElGamal, s: &ScalarNonZero, rng: &mut R) -> ProvedRerandomize {
    // Rerandomize is normally {s * G + in.b, s*in.y + in.c, in.y};
    create_proof(s, &v.y, rng)
}

#[must_use]
pub fn verify_rerandomize(v: &ElGamal, p: &ProvedRerandomize) -> Option<ElGamal> {
  verify_rerandomize_split(&v.b, &v.c, &v.y, &p.0, &p.1)
}

#[must_use]
pub fn verify_rerandomize_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, s: &GroupElement, p: &Proof) -> Option<ElGamal> {
    // slightly different than the others, as we reuse the structure of a standard proof to reconstruct the Rerandomize operation after sending
    if verify_proof(s, gy, p) {
        Some(ElGamal {
            b: s + gb,
            c: **p + gc,
            y: *gy
        })
    } else {
        None
    }
}

//// RESHUFFLE

/// GroupElement is `n*G` if prove_reshuffle with `n` is called.
pub struct ProvedReshuffle(pub GroupElement, pub Proof, pub Proof);

pub fn prove_reshuffle<R: RngCore + CryptoRng>(v: &ElGamal, n: &ScalarNonZero, rng: &mut R) -> ProvedReshuffle {
    // Reshuffle is normally {n * in.b, n * in.c, in.y};
    // NOTE: can be optimised a bit, by fusing the two CreateProofs (because same n is used, saving a n*G operation)
    let (ab, pb) = create_proof(n, &v.b, rng);
    let (ac, pc) = create_proof(n, &v.c, rng);
    debug_assert_eq!(ab, ac);
    ProvedReshuffle(ab, pb, pc)
}

#[must_use]
pub fn verify_reshuffle(v: &ElGamal, p: &ProvedReshuffle) -> Option<ElGamal> {
  verify_reshuffle_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2)
}

#[must_use]
pub fn verify_reshuffle_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gab: &GroupElement, pb: &Proof, pc: &Proof) -> Option<ElGamal> {
    if verify_proof(gab, gb, pb) && verify_proof(gab, gc, pc) {
        Some(ElGamal {
            b: **pb,
            c: **pc,
            y: *gy,
        })
    } else {
        None
    }
}

impl ProvedReshuffle {
    /// Returns `n*G` after `prove_reshuffle(in, n)`.
    pub fn reshuffled_by(&self) -> GroupElement {
        self.0
    }
}
pub struct ProvedReshuffleFromTo(pub GroupElement, pub GroupElement, pub GroupElement, pub ProofInv, pub Proof, pub Proof, pub Proof);
pub fn prove_reshuffle_from_to<R: RngCore + CryptoRng>(v: &ElGamal, n_from: &ScalarNonZero, n_to: &ScalarNonZero, rng: &mut R) -> ProvedReshuffleFromTo {
    // Reshuffle is normally {n_from^-1 * n_to * in.b, n_from^-1 * n_to * in.c, in.y};
    let n = n_from.invert() * n_to;
    let (gn_from, p_n_from_inv) = create_proof_inv(&n_from, rng);
    let gn_from_inv = p_n_from_inv.ga_inv;
    let (gn_to, p_n_from_inv_n_to) = create_proof(&n_to,&*p_n_from_inv, rng);
    let (ab, pb) = create_proof(&n, &v.b, rng);
    let (ac, pc) = create_proof(&n, &v.c, rng);
    debug_assert_eq!(ab, ac);
    debug_assert_eq!(ab, n * G);
    ProvedReshuffleFromTo(gn_from, gn_from_inv, gn_to, p_n_from_inv, p_n_from_inv_n_to, pb, pc)
}

#[must_use]
pub fn verify_reshuffle_from_to(v: &ElGamal, p: &ProvedReshuffleFromTo) -> Option<ElGamal> {
    verify_reshuffle_from_to_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3, &p.4, &p.5, &p.6)
}

#[must_use]
pub fn verify_reshuffle_from_to_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gn_from: &GroupElement, gn_from_inv: &GroupElement, gn_to: &GroupElement, p_n_from_inv: &ProofInv, p_n_from_inv_n_to: &Proof, pb: &Proof, pc: &Proof) -> Option<ElGamal> {
    if verify_proof_inv(&gn_from, &p_n_from_inv) && verify_proof(&gn_to, &*p_n_from_inv, &p_n_from_inv_n_to) && verify_proof(p_n_from_inv_n_to, gb, pb) && verify_proof(p_n_from_inv_n_to, gc, pc) && p_n_from_inv.ga_inv == *gn_from_inv {
        Some(ElGamal {
            b: **pb,
            c: **pc,
            y: *gy,
        })
    } else {
        None
    }
}

impl ProvedReshuffleFromTo {
    pub fn reshuffled_by_from(&self) -> GroupElement {
        self.0
    }
    pub fn reshuffled_by_from_inv(&self) -> GroupElement {
        self.1
    }
    pub fn reshuffled_by_to(&self) -> GroupElement {
        self.2
    }

}


//// REKEY

/// Second GroupElement is `k*G` if prove_rekey with `k` is called.
pub struct ProvedRekey(pub GroupElement,pub Proof,pub GroupElement,pub Proof);

pub fn prove_rekey<R: RngCore + CryptoRng>(v: &ElGamal, k: &ScalarNonZero, rng: &mut R) -> ProvedRekey {
    // Rekey is normmaly {in.b/k, in.c, k*in.y};
    let (ab, pb) = create_proof(&k.invert(), &v.b, rng);
    let (ay, py) = create_proof(k, &v.y, rng);
    ProvedRekey(ab, pb, ay, py)
}

#[must_use]
pub fn verify_rekey(v: &ElGamal, p: &ProvedRekey) -> Option<ElGamal> {
  verify_rekey_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3)
}

#[must_use]
pub fn verify_rekey_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gab: &GroupElement, pb: &Proof, gay: &GroupElement, py: &Proof) -> Option<ElGamal> {
    if verify_proof(gab, gb, pb) && verify_proof(gay, gy, py) {
        Some(ElGamal {
            b: **pb,
            c: *gc,
            y: **py,
        })
    } else {
        None
    }
}

impl ProvedRekey {
    /// Returns `k*G` after `prove_rekey(in, k)`.
    pub fn rekeyed_by(&self) -> GroupElement {
        self.2
    }
}

//// RKS

/// First GroupElement is `n*G` if prove_rks with `n` is called.
/// Second GroupElement is `k*G` if prove_rks with `k` is called.
pub struct ProvedRKS(pub GroupElement, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof);

pub fn prove_rks<R: RngCore + CryptoRng>(v: &ElGamal, k: &ScalarNonZero, n: &ScalarNonZero, rng: &mut R) -> ProvedRKS {
    // RKS is normally {(n / k) * in.B, n * in.C, k * in.Y};
    let a = create_proof(&(n * k.invert()), &v.b, rng);
    let b = create_proof(n, &v.c, rng);
    let c = create_proof(k, &v.y, rng);
    // different order so that first and second group elements for prove_reshuffle,
    // prove_rekey, prove_rks have the same meaning
    ProvedRKS(b.0, b.1, c.0, c.1, a.0, a.1)
}

#[must_use]
pub fn verify_rks(v: &ElGamal, p: &ProvedRKS) -> Option<ElGamal> {
  verify_rks_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3, &p.4, &p.5)
}

#[must_use]
#[allow(clippy::too_many_arguments)]
pub fn verify_rks_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gac: &GroupElement, pc: &Proof, gay: &GroupElement, py: &Proof, gab: &GroupElement, pb: &Proof) -> Option<ElGamal> {
    if verify_proof(gab, gb, pb) && verify_proof(gac, gc, pc)&& verify_proof(gay, gy, py) {
        Some(ElGamal {
            b: **pb,
            c: **pc,
            y: **py,
        })
    } else {
        None
    }
}

impl ProvedRKS {
    /// Returns `n*G` after `prove_rks(in, k, n)`.
    pub fn reshuffled_by(&self) -> GroupElement {
        self.0
    }
    /// Returns `k*G` after `prove_rks(in, k, n)`.
    pub fn rekeyed_by(&self) -> GroupElement {
        self.2
    }
}
pub struct ProvedRKSFromTo(pub GroupElement, pub GroupElement, pub GroupElement, pub ProofInv, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof);

    pub fn prove_rks_from_to<R: RngCore + CryptoRng>(v: &ElGamal, k: &ScalarNonZero, n_from: &ScalarNonZero, n_to: &ScalarNonZero, rng: &mut R) -> ProvedRKSFromTo {
        // RKS is normally {(n_from^-1 * n_to / k) * in.B, n_from^-1 * n_to * in.C, k * in.Y};
        let n = n_from.invert() * n_to;
        let (gn_from, p_n_from_inv) = create_proof_inv(&n_from, rng);
        let gn_from_inv = p_n_from_inv.ga_inv;
        let (gn_to, p_n_from_inv_n_to) = create_proof(&n_to,&*p_n_from_inv, rng);

        let a = create_proof(&(n * k.invert()), &v.b, rng);
        let b = create_proof(&n, &v.c, rng);
        let c = create_proof(k, &v.y, rng);
        // different order so that first and second group elements for prove_reshuffle,
        // prove_rekey, prove_rks have the same meaning

        ProvedRKSFromTo(gn_from, gn_from_inv, gn_to, p_n_from_inv, p_n_from_inv_n_to, b.0, b.1, c.0, c.1, a.0, a.1)
    }

    #[must_use]
    pub fn verify_rks_from_to(v: &ElGamal, p: &ProvedRKSFromTo) -> Option<ElGamal> {
        verify_rks_from_to_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3, &p.4, &p.5, &p.6, &p.7, &p.8, &p.9, &p.10)
    }

    #[must_use]
    #[allow(clippy::too_many_arguments)]
    pub fn verify_rks_from_to_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gn_from: &GroupElement, gn_from_inv: &GroupElement, gn_to: &GroupElement, p_n_from_inv: &ProofInv, p_n_from_inv_n_to: &Proof, gac: &GroupElement, pc: &Proof, gay: &GroupElement, py: &Proof, gab: &GroupElement, pb: &Proof ) -> Option<ElGamal> {
        if verify_proof_inv(&gn_from, &p_n_from_inv) && verify_proof(&gn_to, &*p_n_from_inv, &p_n_from_inv_n_to) && verify_proof(gab, gb, pb) && verify_proof(gac, gc, pc)&& verify_proof(gay, gy, py) && p_n_from_inv.ga_inv == *gn_from_inv {
            Some(ElGamal {
                b: **pb,
                c: **pc,
                y: **py,
            })
        } else {
            None
        }
    }

    impl ProvedRKSFromTo {
        pub fn reshuffled_by_from(&self) -> GroupElement {
            self.0
        }
        pub fn reshuffled_by_from_inv(&self) -> GroupElement {
            self.1
        }
        pub fn reshuffled_by_to(&self) -> GroupElement {
            self.2
        }
        pub fn rekeyed_by(&self) -> GroupElement {
            self.7
        }
    }
}


/// Higher lever API for simple pseudonimisation on a single host.
pub mod simple {

use crate::*;

type GlobalPublicKey = GroupElement;
type GlobalSecretKey = ScalarNonZero;
type GlobalEncryptedPseudonym = ElGamal;
type LocalEncryptedPseudonym = ElGamal;
type LocalPseudonym = GroupElement;
type LocalDecryptionKey = ScalarNonZero;

pub fn generate_global_keys<R: RngCore + CryptoRng>(rng: &mut R) -> (GlobalPublicKey, GlobalSecretKey) {
    // secret key of system
    let y = ScalarNonZero::random(rng);
    // public key of system
    let gy = y*G;
    (gy, y)
}

/// Generates a non-zero scalar.
fn make_factor(typ: &str, secret: &str, context: &str) -> ScalarNonZero {
    let mut hasher = Sha512::default();
    hasher.update(typ.as_bytes());
    hasher.update(b"|");
    hasher.update(secret.as_bytes());
    hasher.update(b"|");
    hasher.update(context.as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    ScalarNonZero::from_hash(&bytes)
}

/// Generates a non-zero scalar.
pub(crate) fn make_pseudonymisation_factor(secret: &str, context: &str) -> ScalarNonZero {
  make_factor("pseudonym", secret, context)
}

/// Generates a non-zero scalar.
pub fn make_decryption_factor(secret: &str, context: &str) -> ScalarNonZero {
  make_factor("decryption", secret, context)
}

/// Generates a encrypted global pseudonym by encrypting a text with ElGamal using the global
/// public key `pkg`.
pub fn generate_pseudonym<R: RngCore + CryptoRng>(identity: &str, pk: &GlobalPublicKey, rng: &mut R) -> GlobalEncryptedPseudonym {
    let mut hasher = Sha512::default();
    hasher.update(identity.as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    let p = GroupElement::from_hash(&bytes);
    encrypt(&p, pk, rng)
}

/// Using a PEP `rks` operation, convert a global encrypted pseudonym to a local encrypted pseudonym,
/// which is:
/// - decryptable with the key `k` that is generated by [make_local_decryption_key] using the same
///   `decryption_context`;
/// - decrypts to the pseudonym that is the global pseudonym multiplied by a factor specific to the
///   `pseudonimisation_context`.
pub fn convert_to_local_pseudonym(p: &GlobalEncryptedPseudonym, secret: &str, decryption_context: &str, pseudonimisation_context: &str) -> LocalEncryptedPseudonym {
    let u = make_pseudonymisation_factor(secret, pseudonimisation_context);
    let t = make_decryption_factor(secret, decryption_context);
    rks(p, &t, &u)
}

pub fn convert_from_local_pseudonym(p: &LocalEncryptedPseudonym, secret: &str, decryption_context: &str, pseudonimisation_context: &str) -> GlobalEncryptedPseudonym {
    let u = make_pseudonymisation_factor(secret, pseudonimisation_context).invert();
    let t = make_decryption_factor(secret, decryption_context).invert();
    rks(p, &t, &u)
}

pub fn make_local_decryption_key(k: &GlobalSecretKey, secret: &str, decryption_context: &str) -> LocalDecryptionKey {
    let t = make_decryption_factor(secret, decryption_context);
    t*k
}

pub fn decrypt_local_pseudonym(p: &LocalEncryptedPseudonym, k: &LocalDecryptionKey) -> LocalPseudonym {
    decrypt(p, k)
}

pub fn rerandomize_global<R: RngCore + CryptoRng>(p: &GlobalEncryptedPseudonym, rng: &mut R) -> GlobalEncryptedPseudonym {
    rerandomize(p, &ScalarNonZero::random(rng))
}

pub fn rerandomize_local<R: RngCore + CryptoRng>(p: &LocalEncryptedPseudonym, rng: &mut R) -> LocalEncryptedPseudonym {
    rerandomize(p, &ScalarNonZero::random(rng))
}

}

pub mod distributed {
    use std::collections::HashMap;
    use crate::*;
    use crate::zkp::*;
    use crate::simple::*;
    use crate::libpep::encode_hex;

    pub type GlobalPublicKey = GroupElement;
    pub type GlobalSecretKey = ScalarNonZero;
    pub type BlindedGlobalSecretKey = ScalarNonZero;
    pub type DecryptionKeyPart = ScalarNonZero;

    pub type Message = ElGamal;
    pub type Context = String;
    pub type SystemId = String;
    pub struct TrustedGroupElementCache {
        pub cache: HashMap<(SystemId, Context), GroupElement>,
    }
    impl TrustedGroupElementCache {
        fn new() -> Self {
            TrustedGroupElementCache {
                cache: HashMap::new(),
            }
        }
        fn store(&mut self, system_id: SystemId, context: Context, element: GroupElement) {
            self.cache.insert((system_id, context), element);
        }
        fn retrieve(&self, system_id: &SystemId, context: &Context) -> Option<&GroupElement> {
            self.cache.get(&(system_id.to_string(), context.to_string()))
        }
    }
    pub struct PEPSystem {
        pub system_id: String,
        pub config: PEPNetworkConfig,
        pseudonymisation_secret: String,
        rekeying_secret: String,
        blinding_factor: ScalarNonZero,
        pub trusted_pseudonymisation_factors: TrustedGroupElementCache,
        pub trusted_inv_pseudonymisation_factors: TrustedGroupElementCache,
        pub trusted_rekeying_factors: TrustedGroupElementCache,
    }
    pub struct PEPNetworkConfig {
        pub global_public_key: GlobalPublicKey,
        pub blinded_global_private_key: ScalarNonZero,
        pub system_ids: Vec<String>,
    }
    impl PEPNetworkConfig {
        pub fn new(global_public_key: GlobalPublicKey, blinded_global_private_key: BlindedGlobalSecretKey, system_ids: Vec<SystemId>) -> Self {
            Self {
                global_public_key,
                blinded_global_private_key,
                system_ids,
            }
        }
    }
    impl PEPSystem {
        pub fn new<R: RngCore + CryptoRng>(system_id: SystemId, config: PEPNetworkConfig, blinding_factor: ScalarNonZero, rng: &mut R) -> Self {
            let pseudonymisation_secret = encode_hex(&ScalarNonZero::random(rng).encode());
            let rekeying_secret = encode_hex(&ScalarNonZero::random(rng).encode());

            Self {
                system_id,
                config,
                pseudonymisation_secret,
                rekeying_secret,
                blinding_factor,
                trusted_pseudonymisation_factors: TrustedGroupElementCache::new(),
                trusted_inv_pseudonymisation_factors: TrustedGroupElementCache::new(),
                trusted_rekeying_factors: TrustedGroupElementCache::new(),
            }
        }
        fn verify_system_pseudonymize(&mut self, system_id: &SystemId, msg_in: &Message, proved_rks: &ProvedRKSFromTo, from_pc: &Context, to_pc: &Context, to_dc: &Context) -> Option<Message> {
            let trusted_from = self.trusted_pseudonymisation_factors.retrieve(system_id, from_pc);
            let trusted_from_inv = self.trusted_inv_pseudonymisation_factors.retrieve(system_id, from_pc);
            let trusted_to = self.trusted_pseudonymisation_factors.retrieve(system_id, to_pc);
            let trusted_k = self.trusted_rekeying_factors.retrieve(system_id, to_dc);

            let msg_out = verify_rks_from_to(msg_in, proved_rks);

            if msg_out.is_none() {
                return None
            }

            if trusted_from.is_some() {
                if proved_rks.reshuffled_by_from() != *trusted_from.unwrap() {
                    return None
                }
            }
            if trusted_from_inv.is_some() {
                if proved_rks.reshuffled_by_from_inv() != *trusted_from_inv.unwrap() {
                    return None
                }
            }
            if trusted_to.is_some() {
                if proved_rks.reshuffled_by_to() != *trusted_to.unwrap() {
                    return None
                }
            }
            if trusted_k.is_some() {
                if proved_rks.rekeyed_by() != *trusted_k.unwrap() {
                    return None
                }
            }

            self.trusted_pseudonymisation_factors.store(system_id.clone(), from_pc.clone(), proved_rks.reshuffled_by_from());
            self.trusted_inv_pseudonymisation_factors.store(system_id.clone(), from_pc.clone(), proved_rks.reshuffled_by_from_inv());
            self.trusted_pseudonymisation_factors.store(system_id.clone(), to_pc.clone(), proved_rks.reshuffled_by_to());
            self.trusted_rekeying_factors.store(system_id.clone(), to_dc.clone(), proved_rks.rekeyed_by());

            msg_out
        }
        pub fn verify_pseudonymize(&mut self, messages: &Vec<(SystemId,Message,ProvedRKSFromTo)>, from_pc: &Context, to_pc: &Context, to_dc: &Context) -> Option<Message> {
            let mut msg_out = None;
            let mut visited_systems = Vec::new();
            for (system_id, msg_in, proved_rks) in messages {
                if !self.config.system_ids.contains(&String::from(system_id)) || visited_systems.contains(&system_id) {
                    // Make sure we only visit each system once, and that the system is part of the network
                    return None
                }
                if msg_out.is_some() {
                    if msg_out.unwrap() != *msg_in {
                        return None
                    }
                }
                msg_out = self.verify_system_pseudonymize(&system_id, &msg_in, &proved_rks, from_pc, to_pc, to_dc);
                visited_systems.push(system_id);
            }
            msg_out
        }
        fn verify_system_transcrypt(&mut self, system_id: &SystemId, msg_in: &Message, proved_rekey: &ProvedRekey, to_dc: &Context) -> Option<Message> {
            let trusted_k = self.trusted_rekeying_factors.retrieve(system_id, to_dc);
            let msg_out = verify_rekey(msg_in, proved_rekey);
            if msg_out.is_none() {
                return None
            }

            if trusted_k.is_some() {
                if proved_rekey.rekeyed_by() != *trusted_k.unwrap() {
                    return None
                }
            }

            self.trusted_rekeying_factors.store(system_id.clone(), to_dc.clone(), proved_rekey.rekeyed_by());

            msg_out
        }
        pub fn verify_transcrypt(&mut self, messages: &Vec<(SystemId,Message,ProvedRekey)>, to_dc: &Context) -> Option<Message> {
            let mut msg_out = None;
            let mut visited_systems = Vec::new();
            for (system_id, msg_in, proved_rekey) in messages {
                if !self.config.system_ids.contains(&String::from(system_id)) || visited_systems.contains(&system_id) {
                    // Make sure we only visit each system once, and that the system is part of the network
                    return None
                }
                if msg_out.is_some() {
                    if msg_out.unwrap() != *msg_in {
                        return None
                    }
                }
                msg_out = self.verify_system_transcrypt(&system_id, &msg_in, &proved_rekey, to_dc);
                visited_systems.push(system_id);
            }
            msg_out
        }
        pub fn pseudonymize<R: RngCore + CryptoRng>(&mut self, message: &Message, from_pc: &Context, to_pc: &Context, to_dc: &Context, rng: &mut R) -> ProvedRKSFromTo {
            let n_from = make_pseudonymisation_factor(&self.pseudonymisation_secret, from_pc);
            let n_to = make_pseudonymisation_factor(&self.pseudonymisation_secret, to_pc);
            let k = make_decryption_factor(&self.rekeying_secret, to_dc);
            prove_rks_from_to(message, &k, &n_from, &n_to, rng)
        }
        pub fn transcrypt<R: RngCore + CryptoRng>(&mut self, message: &Message, to_dc: &Context, rng: &mut R) -> ProvedRekey {
            let k = make_decryption_factor(&self.rekeying_secret, to_dc);
            prove_rekey(message, &k, rng)
        }

        pub fn decryption_key_part(&self, to_dc: &Context) -> DecryptionKeyPart {
            let k = make_decryption_factor(&self.rekeying_secret, to_dc);
            k * &self.blinding_factor.invert()
        }
    }
}
#[cfg(test)]
mod libpep {
    use crate::*;
    use crate::zkp::*;
    use crate::simple::*;
    use crate::distributed::*;
    use rand_core::OsRng;

    #[test]
    fn elgamal_encryption() {
        let mut rng = OsRng;
        // secret key
        let s = ScalarNonZero::random(&mut rng);
        // public key
        let p = s * G;

        // choose a random value to encrypt
        let value = GroupElement::random(&mut rng);

        // encrypt/decrypt this value
        let encrypted = encrypt(&value, &p, &mut OsRng);
        let decrypted = decrypt(&encrypted, &s);

        assert_eq!(value, decrypted);


        let encoded = encrypted.encode();
        let decoded = ElGamal::decode(&encoded);

        assert_eq!(Some(encrypted), decoded);
    }

    #[test]
    fn pep_assumptions() {
        let mut rng = OsRng;
        // secret key of system
        let sk = ScalarNonZero::random(&mut rng);
        // public key of system
        let pk = sk * G;

        // secret key of service provider
        let sj = ScalarNonZero::random(&mut rng);
        let yj = sj * sk;
        assert_eq!(yj * G, sj * pk);

        // Lemma 2: RS(RK(..., k), n) == RK(RS(..., n), k)
        let value = GroupElement::random(&mut rng);
        let encrypted = encrypt(&value, &pk, &mut OsRng);
        let k = ScalarNonZero::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);
        assert_eq!(reshuffle(&rekey(&encrypted, &k), &n), rekey(&reshuffle(&encrypted, &n), &k));
        assert_eq!(reshuffle(&rekey(&encrypted, &k), &n), rks(&encrypted, &k, &n));
    }

    #[test]
    fn elgamal_signature() {
        let mut rng = OsRng;
        // secret key
        let s = ScalarNonZero::random(&mut rng);
        let s2 = ScalarNonZero::random(&mut rng);
        // public key
        let gp = s * G;

        let v = GroupElement::random(&mut rng);
        let mut signature = sign(&v, &s, &mut rng);
        assert!(verify(&v, &signature, &gp));

        signature = sign(&v, &s2, &mut rng);
        assert!(!verify(&v, &signature, &gp));
    }

    #[test]
    fn pep_schnorr_basic_offline() {
        let mut rng = OsRng;
        // given a secret a and public M, proof that a certain triplet (A, M, N) is actually calculated by (a*G, M, a * M)
        // using Fiat-Shamir transform

        // prover
        let a = ScalarNonZero::random(&mut rng);
        let gm = GroupElement::random(&mut rng);

        let (ga, p) = create_proof(&a, &gm, &mut rng);
        assert_eq!(a * gm, *p);

        // verifier
        assert!(verify_proof(&ga, &gm, &p));
    }

    #[test]
    fn pep_schnorr_basic_offline_inv() {
        let mut rng = OsRng;
        // prover
        let a = ScalarNonZero::random(&mut rng);

        let (ga, p) = create_proof_inv(&a, &mut rng); // Use a instead of a_inverse
        assert_eq!(a.invert() * G, *p);

        // verifier
        assert!(verify_proof_inv(&ga, &p));
    }

    #[test]
    fn pep_schnorr_basic_offline_from_to() {
        let mut rng = OsRng;
        // given secret a1, a2 and public Min, proof that a certain triplet (A1, A2, M, N) is actually calculated by (a1 * G, a2 * G, M, a1.inv() * a2 * M)
        // using Fiat-Shamir transform

        // prover
        let a1 = ScalarNonZero::random(&mut rng);
        let a2 = ScalarNonZero::random(&mut rng);
        let a1_inv = a1.invert();

        let ga1 = a1 * G;
        let ga2 = a2 * G;

        let min = GroupElement::random(&mut rng);

        let (_ga1, p_a1_inv) = create_proof_inv(&a1, &mut rng);
        let (_ga1_inv_a2, p_a1_inv_a2) = create_proof(&a2,&*p_a1_inv, &mut rng);
        let (_ga1_inv_a2_min, p_a1_inv_a2_min) = create_proof(&(a1_inv*a2),&min, &mut rng);

        assert_eq!(a1_inv * G, *p_a1_inv);
        assert_eq!(a1_inv*a2 * G, *p_a1_inv_a2);
        assert_eq!(a1_inv*a2 * min, *p_a1_inv_a2_min);

        // verifier
        assert!(verify_proof_inv(&ga1, &p_a1_inv));
        assert!(verify_proof(&ga2, &*p_a1_inv, &p_a1_inv_a2));
        assert!(verify_proof(&*p_a1_inv_a2, &min, &p_a1_inv_a2_min));

        // first we proof to know a scalar that is indeed the inverse of a1, based on A1
        // then we proof to know a different scalar that is a1*^-1 * a2, based on A2
        // finally, we proof that our message M was multiplied by that number.
    }

    #[test]
    fn pep_schnorr_rerandomize() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let s = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rerandomize(&msg, &s, &mut rng);

        let checked = verify_rerandomize(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&rerandomize(&msg, &s), checked.as_ref().unwrap());
    }

    #[test]
    fn pep_schnorr_reshuffle() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_reshuffle(&msg, &n, &mut rng);

        let checked = verify_reshuffle(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(n*gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&reshuffle(&msg, &n), checked.as_ref().unwrap());
        assert_eq!(n*G, proved.reshuffled_by());
    }

    #[test]
    fn pep_schnorr_reshuffle_from_to() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let n_from = ScalarNonZero::random(&mut rng);
        let n_to = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_reshuffle_from_to(&msg, &n_from, &n_to, &mut rng);

        let checked = verify_reshuffle_from_to(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(n_from.invert()*n_to*gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&reshuffle(&msg, &(n_from.invert()*n_to)), checked.as_ref().unwrap());
        assert_eq!(n_from*G, proved.reshuffled_by_from());
        assert_eq!(n_to*G, proved.reshuffled_by_to());
    }


    #[test]
    fn pep_schnorr_rekey() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rekey(&msg, &k, &mut rng);
        let checked = verify_rekey(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(proved.rekeyed_by(), k*G);
        assert_eq!(gm, decrypt(checked.as_ref().unwrap(), &(k*y)));
    }

    #[test]
    fn pep_schnorr_rks() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rks(&msg, &k, &n, &mut rng);

        let checked = verify_rks(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(proved.rekeyed_by(), k*G);
        assert_eq!(n*gm, decrypt(checked.as_ref().unwrap(), &(k*y)));
    }

    #[test]
    fn pep_schnorr_rks_from_to() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);
        let n_from = ScalarNonZero::random(&mut rng);
        let n_to = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rks_from_to(&msg, &k, &n_from, &n_to, &mut rng);

        let checked = verify_rks_from_to(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(proved.rekeyed_by(), k*G);
        assert_eq!(n_from.invert()*n_to*gm, decrypt(checked.as_ref().unwrap(), &(k*y)));
        assert_eq!(n_from*G, proved.reshuffled_by_from());
        assert_eq!(n_to*G, proved.reshuffled_by_to());
    }

    // https://stackoverflow.com/questions/52987181/how-can-i-convert-a-hex-string-to-a-u8-slice
    use std::{fmt::Write, num::ParseIntError};

    pub fn decode_hex(s: &str) -> Result<Vec<u8>, ParseIntError> {
        (0..s.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&s[i..i + 2], 16))
            .collect()
    }
    #[allow(dead_code)]
    pub fn encode_hex(bytes: &[u8]) -> String {
        let mut s = String::with_capacity(bytes.len() * 2);
        for &b in bytes {
            write!(&mut s, "{:02x}", b).unwrap();
        }
        s
    }

    #[test]
    fn pep_high_level_api() {
        let mut rng = OsRng;
        let (public_key, secret_key) = generate_global_keys(&mut rng);
        //std::cout << "global public key: " << publicKey.hex() << std::endl;
        //std::cout << "global secret key: " << secretKey.hex() << std::endl;

        let id = "foobar";
        let mut gep = generate_pseudonym(id, &public_key, &mut rng);
        //gep = GlobalEncryptedPseudonym::FromHex(gep.hex());
        //std::cout << "global pseudonym for '" << id << "': " << gep.hex() << std::endl;
        gep = rerandomize_global(&gep, &mut rng);
        //std::cout << "global pseudonym for '" << id << "': " << gep.hex() << " (after randomize)" << std::endl;
        //gep = GlobalEncryptedPseudonym::FromHex(gep.hex());
        let mut lep = convert_to_local_pseudonym(&gep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        //lep = LocalEncryptedPseudonym::FromHex(lep.hex());
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << std::endl;
        lep = rerandomize_local(&lep, &mut rng);
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << " (after randomize)" << std::endl;

        let decryption_key = make_local_decryption_key(&secret_key, "very_secret_on_server", "login_session_of_user");
        let lp = decrypt_local_pseudonym(&lep, &decryption_key);
        //let expected = LocalPseudonym::from_hex("4854bb37a8f2e9555f317614290cbef72210901e05f0e0a6623e10df30dfa739");
        let hex = "be26a708fcf722db8d19f6d8c8443794156af30b17c44bcf4bb41791c0708945";
        let expected = decode_hex(hex).unwrap();
        //assert_eq!(lp.hex(), expected.hex());
        assert_eq!(&lp.encode()[..], &expected);
        //std::cout << "(decrypted local pseudonym) for '" << id << "': " << lp.hex() << std::endl;
        
        let gep = convert_from_local_pseudonym(&lep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        let mut lep = convert_to_local_pseudonym(&gep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        //lep = LocalEncryptedPseudonym::FromHex(lep.hex());
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << std::endl;
        lep = rerandomize_local(&lep, &mut rng);
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << " (after randomize)" << std::endl;

        let decryption_key = make_local_decryption_key(&secret_key, "very_secret_on_server", "login_session_of_user");
        let lp = decrypt_local_pseudonym(&lep, &decryption_key);
        //let expected = LocalPseudonym::from_hex("4854bb37a8f2e9555f317614290cbef72210901e05f0e0a6623e10df30dfa739");
        let hex = "be26a708fcf722db8d19f6d8c8443794156af30b17c44bcf4bb41791c0708945";
        let expected = decode_hex(hex).unwrap();
        //assert_eq!(lp.hex(), expected.hex());
        assert_eq!(&lp.encode()[..], &expected);
    }

    #[test]
    fn distributed_pep_api() {
        let n = 5;
        let mut rng = OsRng;

        let (global_public_key, global_secret_key) = generate_global_keys(&mut rng);

        let mut blinding_factors = Vec::new();
        for _ in 0..n {
            let blinding_factor = ScalarNonZero::random(&mut rng);
            blinding_factors.push(blinding_factor);
        }
        let blinded_global_secret_key = blinding_factors.iter().fold(global_secret_key, |acc, s| acc * s);

        let mut systems = Vec::new();
        for i in 0..n {
            let system_id: SystemId = format!("system-{}", i);
            let system = PEPSystem::new(system_id, PEPNetworkConfig::new(global_public_key, blinded_global_secret_key, (0..n).map(|i| format!("system-{}", i)).collect()), blinding_factors[i], &mut rng);
            systems.push(system);
        }

        fn pseudonymize_through_network(data_in: &GroupElement, from_pc: &Context, to_pc: &Context, to_dc: &Context, systems: &mut Vec<PEPSystem>, rng: &mut OsRng) -> GroupElement {
            let mut network = Vec::new();

            let msg_in = encrypt(&data_in, &systems[0].config.global_public_key, rng);

            let proven = systems[0].pseudonymize(&msg_in, from_pc, to_pc, to_dc, rng);
            network.push((systems[0].system_id.clone(), msg_in.clone(), proven));

            for i in 1..systems.len() {
                let system = &mut systems[i];
                let msg_in = system.verify_pseudonymize(&network, &from_pc, &to_pc, &to_dc).unwrap();
                let proven = system.pseudonymize(&msg_in, from_pc, to_pc, to_dc, rng);
                network.push((system.system_id.clone(), msg_in.clone(), proven));
            }
            let msg_out = systems[0].verify_pseudonymize(&network, from_pc, to_pc, to_dc).unwrap();
            let decryption_key = systems.iter().fold(systems[0].config.blinded_global_private_key, |acc, s| acc * s.decryption_key_part(to_dc));
            let data_out = decrypt(&msg_out, &decryption_key);
            data_out
        }

        fn transcrypt_through_network(data_in: &GroupElement, to_dc: &Context, systems: &mut Vec<PEPSystem>, rng: &mut OsRng) -> GroupElement {
            let mut network = Vec::new();

            let msg_in = encrypt(&data_in, &systems[0].config.global_public_key, rng);

            let proven = systems[0].transcrypt(&msg_in, to_dc, rng);
            network.push((systems[0].system_id.clone(), msg_in.clone(), proven));

            for i in 1..systems.len() {
                let system = &mut systems[i];
                let msg_in = system.verify_transcrypt(&network, &to_dc).unwrap();
                let proven = system.transcrypt(&msg_in, to_dc, rng);
                network.push((system.system_id.clone(), msg_in.clone(), proven));
            }
            let msg_out = systems[0].verify_transcrypt(&network, to_dc).unwrap();
            let decryption_key = systems.iter().fold(systems[0].config.blinded_global_private_key, |acc, s| acc * s.decryption_key_part(to_dc));
            let data_out = decrypt(&msg_out, &decryption_key);
            data_out
        }

        let pc_a: Context = Context::from("pc-user-a");
        let dc_a1: Context = Context::from("dc-user-a1");
        let pc_b: Context = Context::from("pc-user-b");
        let dc_b1: Context = Context::from("dc-user-b1");
        let dc_b2: Context = Context::from("dc-user-b2");
        let pc_c: Context = Context::from("pc-user-c");
        let dc_c1: Context = Context::from("dc-user-c1");

        let lp_a = GroupElement::random(&mut rng);
        let lp_b = pseudonymize_through_network(&lp_a, &pc_a, &pc_b, &dc_b1, &mut systems, &mut rng);
        assert_ne!(lp_a, lp_b);

        // Pseudonymization is invertible
        let lp_a_return = pseudonymize_through_network(&lp_b, &pc_b, &pc_a, &dc_a1, &mut systems, &mut rng);
        assert_eq!(lp_a, lp_a_return);

        // Pseudonymization is transitive
        let lp_c = pseudonymize_through_network(&lp_a, &pc_a, &pc_c, &dc_c1, &mut systems, &mut rng);
        let lp_c_via_b = pseudonymize_through_network(&lp_b, &pc_b, &pc_c, &dc_c1, &mut systems, &mut rng);
        assert_eq!(lp_c, lp_c_via_b);

        // Pseudonymization is deterministic for user
        let lp_b_2 = pseudonymize_through_network(&lp_a, &pc_a, &pc_b, &dc_b2, &mut systems, &mut rng);
        assert_eq!(lp_b, lp_b_2);
        assert_ne!(lp_b, lp_c);

        let plaintext_a = GroupElement::random(&mut rng);
        let plaintext_b = transcrypt_through_network(&plaintext_a, &dc_b1, &mut systems, &mut rng);
        assert_eq!(plaintext_a, plaintext_b);
    }
}
