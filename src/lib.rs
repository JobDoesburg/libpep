//! This library implements the PEP encryption based on ElGamal, and operations on these encrypted messages. A message [GroupElement] `M` can be encrypted for a receiver which has public key [GroupElement] `Y` associated with it, belonging to secret key [ScalarNonZero] `y`. This encryption is random: a different random [ScalarNonZero] `r` can be used during encryption for a specific public key, resulting in different ciphertexts (encrypted messages) but decryptable by only knowing the secret key. We represent this encryption function as `EG(r, M, Y)`, which is implemented in Rust as [encrypt]. Encrypted messages `msg` are often pseudonyms or AES keys (see below).
//!
//! [ElGamal] ciphertext on which the three PEP operations can be performed:
//! - [rerandomize] by [ScalarNonZero] `s`: change encrypted representation, same contents when decrypted;
//! - [reshuffle] by [ScalarNonZero] `n`: change encrypted representation so that is has different contents when decrypted equal to `n*msg`, if the original encrypted message was [GroupElement] `msg`.
//! - [rekey] by [ScalarNonZero] `k`: change encrypted representation, so it can be decrypted by a different key `k*y` if the input can be decrypted by [ScalarNonZero] `y`.
//!
//! There are also zero knowledge proof version of these operations in module [zkp]. These are needed so that a party can prove to another party that it has applied the operation on the input data, without revealing the factors used in the operation.
//!
//! When distributing trust over multiple central servers, these zero knowledge proofs are essential, so that a malfunctioning server can not violate security guarantees of the system. For example, if reshuffling by `n` a pseudonym on a server, the requestor wants to make sure that the sent over pseudonym is actually reshuffled using the correct factor `n`, instead of a random other pseudonym or a different factor.
//!
//! Same library in different languages:
//! - [libpep-cpp](https://github.com/bvgastel/libpep-cpp) (C++);
//! - [libpep on crates.io](https://crates.io/crates/libpep) (Rust).
//!
//! ## Applications
//!
//! For **pseudonimisation**, the core operation is [reshuffle] with `n`. It modifies a main pseudonym with a factor `n` that is specific to a user (or user group) receiving the pseudonym. After applying a user specific factor `n`, a pseudonym is called a *local pseudonym*. The factor `n` is typically tied to the *access group of a user*.
//!
//! Using only a reshuffle is insufficient, as the pseudonym is still encrypted with the public key `Y` (which can be decrypted by the secret key `y`). To allow a user to decrypt the encrypted pseudonym, a [rekey] with `k` is needed, in combination with a protocol to hand the user the secret key `k*y`. The factor `k` is typically tied to the *current session of a user*.
//!
//! To make pseudonyms harder to trace, [rerandomize] is applied frequently. This way a binary compare of the encrypted pseudonym will not leak any information.
//!
//! For **data protection**, the [rekey] operation described above allows a [GroupElement] `msg` to be
//! decryptable with another key but decryption results in the same original GroupElement `msg`. This GroupElement
//! can be used as an AES key to encrypt a larger message. Care must be taken that such an AES key is
//! not functioning as a defacto global identifier.
//!
//! ## Implementation
//!
//! This library is using the Ristretto encoding on Curve25519, implemented in the curve25519-dalek crate. There are a number of arithmetic rules for scalars and group elements: group elements can be added and subtracted from each other. Scalars support addition, subtraction, and multiplication. Division can be done by multipling with the inverse (using `s.invert()` for non-zero scalar `s`). A scalar can be converted to a group element (by multiplying with the special generator `G`), but not the other way around. Group elements can also be multiplied by a scalar.
//!
//! Group elements have an *almost* 32 byte range (top bit is always zero, and some other values are invalid). Therefore, not all AES-256 keys (using the full 32 bytes range) are valid group elements. But all group elements are valid AES-256 keys. Group elements can be generated by [GroupElement::random] or [GroupElement::from_hash]. Scalars are also 32 bytes, and can be generated with [ScalarNonZero::random] or [ScalarNonZero::from_hash].
//!
//! The zero knowledge proofs are offline Schnorr proofs, based on a Fiat-Shamir transform. The hashing algorithm used is SHA512.
use curve25519_dalek::ristretto::RistrettoPoint;
use curve25519_dalek::ristretto::CompressedRistretto;
use curve25519_dalek::traits::Identity;

extern crate rand_core;
extern crate sha2;

use rand::CryptoRng;
use rand::RngCore;
use sha2::{Sha512, Digest};

/// Constant so that a [ScalarNonZero]/[ScalarCanBeZero] s can be converted to a [GroupElement] by performing `s * G`.
const G: GroupElement = GroupElement(curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT);

/// Returned if a zero scalar is inverted (which is similar to why a division by zero is not
/// possible).
#[derive(Debug)]
pub struct ZeroArgumentError;

/// Element on a group. Can not be converted to a scalar. Supports addition and substraction. Multiplication by a scalar is supported.
#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub struct GroupElement(RistrettoPoint);

impl GroupElement {
    pub fn encode(&self) -> [u8; 32] {
        self.0.compress().0
    }

    pub fn decode_from_slice(v: &[u8]) -> Option<Self> {
        if v.len() != 32 {
            None
        } else {
            CompressedRistretto::from_slice(v).decompress().map(Self)
        }
    }

    pub fn decode(v: [u8; 32]) -> Option<Self> {
        CompressedRistretto(v).decompress().map(Self)
    }
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        Self(RistrettoPoint::random(rng))
    }
    pub fn from_hash(v: &[u8; 64]) -> Self {
        Self(RistrettoPoint::from_uniform_bytes(v))
    }
    pub fn from_string(s: &str) -> Option<Self> {
        if s.len() != 64 { // A valid hexadecimal string should be 64 characters long for 32 bytes
            return None;
        }
        let bytes = match hex::decode(s) {
            Ok(v) => v,
            Err(_) => return None,
        };
        CompressedRistretto::from_slice(&bytes).decompress().map(Self)
    }
    pub fn to_string(&self) -> String {
        hex::encode(self.encode())
    }
    pub fn identity() -> Self {
        Self(RistrettoPoint::identity())
    }
}

/// Scalar, always non-zero. Can be converted to a GroupElement. Supports multiplication, and inversion (so division is possible). For addition and substraction, use [ScalarCanBeZero].
#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub struct ScalarNonZero(curve25519_dalek::scalar::Scalar);

impl ScalarNonZero {
    /// Always return a non-zero scalar.
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        loop {
            let retval = curve25519_dalek::scalar::Scalar::random(rng);
            if !retval.as_bytes().iter().all(|x| *x == 0) {
                return Self(retval);
            }
        }
    }

    pub fn from_hash(v: &[u8; 64]) -> Self {
        let retval = curve25519_dalek::scalar::Scalar::from_bytes_mod_order_wide(v);
        if retval.as_bytes().iter().all(|x| *x == 0) {
            Self(curve25519_dalek::scalar::Scalar::one())
        } else {
            Self(retval)
        }
    }

    pub fn one() -> Self {
        Self(curve25519_dalek::scalar::Scalar::one())
    }

    pub fn invert(&self) -> Self {
        Self(self.0.invert())
    }
}

/// Scalar, can be zero. Can be converted to a GroupElement. Supports multiplication, inversion (so division is possible), addition and substraction.
#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub struct ScalarCanBeZero(curve25519_dalek::scalar::Scalar);

impl ScalarCanBeZero {
    pub fn decode_from_slice(v: &[u8]) -> Option<Self> {
        if v.len() != 32 {
            None
        } else {
            let mut tmp = [0u8; 32];
            tmp.copy_from_slice(v);
            curve25519_dalek::scalar::Scalar::from_canonical_bytes(tmp).map(Self)
        }
    }

    pub fn decode(v: [u8; 32]) -> Option<Self> {
        curve25519_dalek::scalar::Scalar::from_canonical_bytes(v).map(Self)
    }

    pub fn one() -> Self {
        Self(curve25519_dalek::scalar::Scalar::one())
    }

    pub fn zero() -> Self {
        Self(curve25519_dalek::scalar::Scalar::zero())
    }

    pub fn is_zero(&self) -> bool {
        self.0.as_bytes().iter().all(|x| *x == 0)
    }
}

impl From<ScalarNonZero> for ScalarCanBeZero {
    fn from(value: ScalarNonZero) -> Self {
        Self(value.0)
    }
}

impl TryFrom<ScalarCanBeZero> for ScalarNonZero {
    type Error = ZeroArgumentError;

    fn try_from(value: ScalarCanBeZero) -> Result<Self, Self::Error> {
        if value.is_zero() {
            Err(ZeroArgumentError)
        } else {
            Ok(Self(value.0))
        }
    }
}

pub trait ScalarTraits {
    fn encode(&self) -> [u8; 32] {
        let mut retval = [0u8; 32];
        retval[0..32].clone_from_slice(self.raw().as_bytes());
        retval
    }
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar;
}

impl ScalarTraits for ScalarCanBeZero {
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar {
        &self.0
    }
}

impl ScalarTraits for ScalarNonZero {
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar {
        &self.0
    }
}

impl<'a, 'b> std::ops::Add<&'b ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 + rhs.0)
    }
}

impl<'b> std::ops::Add<&'b ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(mut self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a> std::ops::Add<ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(self, mut rhs: ScalarCanBeZero) -> Self::Output {
        rhs.0 += self.0;
        rhs
    }
}

impl std::ops::Add<ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(mut self, rhs: ScalarCanBeZero) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Sub<&'b ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 - rhs.0)
    }
}

impl<'b> std::ops::Sub<&'b ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(mut self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a> std::ops::Sub<ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(self, rhs: ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 - rhs.0)
    }
}

impl std::ops::Sub<ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(mut self, rhs: Self) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Mul<&'b ScalarNonZero> for &'a ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(self, rhs: &'b ScalarNonZero) -> Self::Output {
        ScalarNonZero(self.0 * rhs.0)
    }
}

impl<'b> std::ops::Mul<&'b ScalarNonZero> for ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(mut self, rhs: &'b ScalarNonZero) -> Self::Output {
        self.0 *= rhs.0;
        self
    }
}

impl<'a> std::ops::Mul<ScalarNonZero> for &'a ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(self, mut rhs: ScalarNonZero) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}

impl std::ops::Mul<ScalarNonZero> for ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(mut self, rhs: Self) -> Self::Output {
        self.0 *= rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Add<&'b GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn add(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 + rhs.0)
    }
}

impl<'b> std::ops::Add<&'b GroupElement> for GroupElement {
    type Output = GroupElement;

    fn add(mut self, rhs: &'b GroupElement) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a> std::ops::Add<GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn add(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 += self.0;
        rhs
    }
}

impl std::ops::Add<GroupElement> for GroupElement {
    type Output = GroupElement;

    fn add(mut self, rhs: Self) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Sub<&'b GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn sub(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 - rhs.0)
    }
}

impl<'b> std::ops::Sub<&'b GroupElement> for GroupElement {
    type Output = GroupElement;

    fn sub(mut self, rhs: &'b GroupElement) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a> std::ops::Sub<GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn sub(self, rhs: GroupElement) -> Self::Output {
        GroupElement(self.0 - rhs.0)
    }
}

impl std::ops::Sub<GroupElement> for GroupElement {
    type Output = GroupElement;

    fn sub(mut self, rhs: Self) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Mul<&'b GroupElement> for &'a ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}

impl<'b> std::ops::Mul<&'b GroupElement> for ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}

impl<'a> std::ops::Mul<GroupElement> for &'a ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}

impl std::ops::Mul<GroupElement> for ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}

impl<'a, 'b> std::ops::Mul<&'b GroupElement> for &'a ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}

impl<'b> std::ops::Mul<&'b GroupElement> for ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}

impl<'a> std::ops::Mul<GroupElement> for &'a ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}

impl std::ops::Mul<GroupElement> for ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}

/// ElGamal ciphertext on which the three PEP operations can be performed:
/// - [rerandomize]: change encrypted representation, same contents when decrypted;
/// - [reshuffle]: change encrypted representation, different contents when decrypted;
/// - [rekey]: change encrypted representation, can be decrypted by a different key.
#[derive(Debug, Eq, PartialEq)]
pub struct ElGamal {
    pub b: GroupElement,
    pub c: GroupElement,
    pub y: GroupElement,
}


impl ElGamal {
    pub fn encode(&self) -> [u8; 96] {
        let mut retval = [0u8; 96];
        retval[0..32].clone_from_slice(self.b.0.compress().as_bytes());
        retval[32..64].clone_from_slice(self.c.0.compress().as_bytes());
        retval[64..96].clone_from_slice(self.y.0.compress().as_bytes());
        retval
    }

    pub fn decode(v: &[u8]) -> Option<Self> {
        if v.len() != 96 {
            None
        } else {
            Some(Self {
                b: GroupElement::decode_from_slice(&v[0..32])?,
                c: GroupElement::decode_from_slice(&v[32..64])?,
                y: GroupElement::decode_from_slice(&v[64..96])?,
            })
        }
    }

    pub fn clone(&self) -> Self {
        Self {
            b: self.b,
            c: self.c,
            y: self.y,
        }
    }
}

/// Encrypt message [GroupElement] `msg` using public key [GroupElement] `public_key` to a ElGamal tuple.
pub fn encrypt<R: RngCore + CryptoRng>(msg: &GroupElement, public_key: &GroupElement, rng: &mut R) -> ElGamal {
    let r = ScalarNonZero::random(rng); // random() should never return a zero scalar
    debug_assert!(public_key != &GroupElement::identity()); // we should not encrypt anything with an empty public key, as this will result in plain text send over the line
    ElGamal {
        b: r * G,
        c: msg + r * public_key,
        y: *public_key,
    }
}


/// Encrypt message [GroupElement] `msg` using randomized public key [GroupElement] `public_key` and the randomizer [GroupElement] `randomizer_g` to a ElGamal tuple. A randomized public key can be computed from a [GroupElement] public key `pk` by `randomizer*pk` using a random [ScalarNonZero] randomizer. The `randomizer` can be converted to the necessary [GroupElement] argument by doing `randomizer*G`.
pub fn encrypt_using_randomizer<R: RngCore + CryptoRng>(msg: &GroupElement, public_key: &GroupElement, randomizer_g: &GroupElement, rng: &mut R) -> ElGamal {
    debug_assert!(public_key != &GroupElement::identity()); // we should not encrypt anything with an empty public key, as this will result in plain text send over the line
    let r = ScalarNonZero::random(rng); // random() should never return a zero scalar
    ElGamal {
        b: r * G,
        c: msg + r * public_key + r * randomizer_g,
        y: *public_key,
    }
}

/// Decrypt ElGamal tuple (encrypted using `secret_key * G`) using secret key [ScalarNonZero] `secret_key`.
pub fn decrypt(s: &ElGamal, secret_key: &ScalarNonZero) -> GroupElement {
    s.c - secret_key * s.b
}

/// Change encrypted representation using [ScalarNonZero] `s`, same contents when decrypted.
pub fn rerandomize(v: &ElGamal, s: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: s * G + v.b,
        c: s * v.y + v.c,
        y: v.y,
    }
}

/// Change encrypted representation using [ScalarNonZero] `k`, so it can be decrypted by a different key `k*y` if the input can be decrypted by [ScalarNonZero] `y`.
pub fn rekey(v: &ElGamal, k: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: k.invert() * v.b,
        c: v.c,
        y: k * v.y,
    }
}

/// Change encrypted representation using [ScalarNonZero] `n` so that is has different contents when decrypted equal to `n*msg`, if the original encrypted message was [GroupElement] `msg`. 
pub fn reshuffle(v: &ElGamal, n: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: n * v.b,
        c: n * v.c,
        y: v.y,
    }
}

pub fn reshuffle_from_to(v: &ElGamal, n_from: &ScalarNonZero, n_to: &ScalarNonZero) -> ElGamal {
    let n = n_from.invert() * n_to;
    reshuffle(v, &n)
}


/// Combination of `rekey(k)` and `reshuffle(n)`
pub fn rsk(v: &ElGamal, n: &ScalarNonZero, k: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: (n * k.invert()) * v.b,
        c: n * v.c,
        y: k * v.y,
    }
}

pub fn rsk_from_to(v: &ElGamal, n_from: &ScalarNonZero, n_to: &ScalarNonZero, k: &ScalarNonZero) -> ElGamal {
    let n = n_from.invert() * n_to;
    rsk(v, &n, k)
}

//////////////////////////

/// Zero-knowledge proofs useful for example if PEP is distributed across multiple hosts.
pub mod zkp {
    use std::ops::Deref;
    use crate::*;

    // Offline Schnorr proof using Fiat-Shamir transform.
    // Proof that given a GroupElement `m` and a scalar `a`,
    // member `n` is equal to `a*m`. This can be verified using
    // this struct, the original `m` and `a*G`, so that the original
    // scalar `a` remains secret.
    pub struct Proof {
        pub n: GroupElement,
        pub c1: GroupElement,
        pub c2: GroupElement,
        pub s: ScalarCanBeZero,
    }

    impl Deref for Proof {
        type Target = GroupElement;

        fn deref(&self) -> &Self::Target {
            &self.n
        }
    }

    // returns <A=a*G, Proof with a value N = a*M>
    pub fn create_proof<R: RngCore + CryptoRng>(a: &ScalarNonZero /*secret*/, gm: &GroupElement /*public*/, rng: &mut R) -> (GroupElement, Proof) {
        let r = ScalarNonZero::random(rng);

        let ga = a * G;
        let gn = a * gm;
        let gc1 = r * G;
        let gc2 = r * gm;

        let mut hasher = Sha512::default();
        hasher.update(ga.encode());
        hasher.update(gm.encode());
        hasher.update(gn.0.compress().as_bytes());
        hasher.update(gc1.0.compress().as_bytes());
        hasher.update(gc2.0.compress().as_bytes());
        let mut bytes = [0u8; 64];
        bytes.copy_from_slice(hasher.finalize().as_slice());
        let e = ScalarNonZero::from_hash(&bytes);
        let s = ScalarCanBeZero::from(a * e) + ScalarCanBeZero::from(r);
        (ga, Proof { n: gn, c1: gc1, c2: gc2, s })
    }

    #[must_use]
    pub fn verify_proof_split(ga: &GroupElement, gm: &GroupElement, gn: &GroupElement, gc1: &GroupElement, gc2: &GroupElement, s: &ScalarCanBeZero) -> bool {
        let mut hasher = Sha512::default();
        hasher.update(ga.0.compress().as_bytes());
        hasher.update(gm.0.compress().as_bytes());
        hasher.update(gn.0.compress().as_bytes());
        hasher.update(gc1.0.compress().as_bytes());
        hasher.update(gc2.0.compress().as_bytes());
        let mut bytes = [0u8; 64];
        bytes.copy_from_slice(hasher.finalize().as_slice());
        let e = ScalarNonZero::from_hash(&bytes);
        // FIXME: speed up with https://docs.rs/curve25519-dalek/latest/curve25519_dalek/traits/trait.VartimeMultiscalarMul.html
        // FIXME: check if a faster non-constant time equality can be used
        s * G == e * ga + gc1 && s * gm == e * gn + gc2
        // (a*e + r)*G = e*a*G + r*G
        // (a*e + r)*gm == e*a*gm + r*gm
    }

    #[must_use]
    pub fn verify_proof(ga: &GroupElement, gm: &GroupElement, p: &Proof) -> bool {
        verify_proof_split(ga, gm, &p.n, &p.c1, &p.c2, &p.s)
    }

    //// SIGNATURES

    type Signature = Proof;

    pub fn sign<R: RngCore + CryptoRng>(message: &GroupElement, secret_key: &ScalarNonZero, rng: &mut R) -> Signature {
        create_proof(secret_key, message, rng).1
    }

    #[must_use]
    pub fn verify(message: &GroupElement, p: &Signature, public_key: &GroupElement) -> bool {
        verify_proof(public_key, message, p)
    }

    pub type PEPFactor = ScalarNonZero;

    #[derive(Eq, PartialEq, Clone, Copy)]
    pub struct PEPFactorVerifiers(pub GroupElement, pub GroupElement);

    pub struct PEPFactorVerifiersProof(Proof, ScalarNonZero, GroupElement);

    pub fn generate_pep_factor_verifiers<R: RngCore + CryptoRng>(a: &ScalarNonZero, rng: &mut R) -> (PEPFactorVerifiers, PEPFactorVerifiersProof) {
        let r = ScalarNonZero::random(rng);
        let gra = a * r * G;
        let (gai, pai) = create_proof(&a.invert(), &gra, rng);
        // Checking pki.n == gr proves that a.invert()*a == 1.
        // Assume a'^-1 * (a*r*G) = r*G, then a = a' trivially holds for any a, a', r
        (PEPFactorVerifiers(a * G, gai), PEPFactorVerifiersProof(pai, r, gra))
    }

    #[must_use]
    pub fn verify_pep_factor_verifiers(verifiers: &PEPFactorVerifiers, proof: &PEPFactorVerifiersProof) -> bool {
        let PEPFactorVerifiers(ga, gai) = verifiers;
        let PEPFactorVerifiersProof(pai, r, gra) = proof;
        verify_proof(gai, gra, pai) && pai.n == r * G && r * ga == *gra
    }

    //// RERANDOMIZE

    // We are re-using some variables from the Proof to reconstruct the Rerandomize operation.
    // This way, we only need 1 Proof object (which are fairly large)
    pub struct ProvedRerandomize(GroupElement, Proof);

    impl ProvedRerandomize {
        pub fn new<R: RngCore + CryptoRng>(original: &ElGamal, s: &ScalarNonZero, rng: &mut R) -> Self {
            // Rerandomize is normally {s * G + in.b, s*in.y + in.c, in.y};
            let (gs, p) = create_proof(s, &original.y, rng);
            Self(gs, p)
        }
        pub fn verified_reconstruct(&self, original: &ElGamal) -> Option<ElGamal> {
            if self.verify(original) {
                Some(self.reconstruct(original))
            } else {
                None
            }
        }
        fn reconstruct(&self, original: &ElGamal) -> ElGamal {
            ElGamal {
                b: self.0 + original.b,
                c: *self.1 + original.c,
                y: original.y,
            }
        }
        fn verify(&self, original: &ElGamal) -> bool {
            Self::verify_split(&original.b, &original.c, &original.y, &self.0, &self.1)
        }
        fn verify_rerandomized(&self, original: &ElGamal, new: &ElGamal) -> bool {
            self.verify(original) && new.b == self.0 + original.b && new.c == *self.1 + original.c && new.y == original.y
        }
        fn verify_split(_gb: &GroupElement, _gc: &GroupElement, gy: &GroupElement, gs: &GroupElement, p: &Proof) -> bool {
            // slightly different than the others, as we reuse the structure of a standard proof to reconstruct the Rerandomize operation after sending
            verify_proof(gs, gy, p)
        }
    }
    //// RESHUFFLE

    pub type ReshuffleFactor = ScalarNonZero;
    pub type ReshuffleFactorVerifiers = PEPFactorVerifiers;

    /// GroupElement is `n*G` if prove_reshuffle with `n` is called.
    pub struct ProvedReshuffle(pub Proof, pub Proof);

    impl ProvedReshuffle {
        pub fn new<R: RngCore + CryptoRng>(v: &ElGamal, n: &ReshuffleFactor, rng: &mut R) -> Self {
            // Reshuffle is normally {n * in.b, n * in.c, in.y};
            // NOTE: can be optimised a bit, by fusing the two CreateProofs (because same n is used, saving a n*G operation)
            let (_gn, pb) = create_proof(&n, &v.b, rng);
            let (_gn, pc) = create_proof(&n, &v.c, rng);
            Self(pb, pc)
        }
        pub fn verified_reconstruct(&self, original: &ElGamal, verifiers: &ReshuffleFactorVerifiers) -> Option<ElGamal> {
            if self.verify(original, verifiers) {
                Some(self.reconstruct(original))
            } else {
                None
            }
        }
        fn reconstruct(&self, original: &ElGamal) -> ElGamal {
            ElGamal {
                b: *self.0,
                c: *self.1,
                y: original.y,
            }
        }
        fn verify(&self, original: &ElGamal, verifiers: &ReshuffleFactorVerifiers) -> bool {
            Self::verify_split(&original.b, &original.c, &original.y, &verifiers.0, &self.0, &self.1)
        }
        fn verify_reshuffled(&self, original: &ElGamal, new: &ElGamal, verifiers: &ReshuffleFactorVerifiers) -> bool {
            self.verify(original, verifiers) && new.b == self.0.n && new.c == self.1.n && new.y == original.y
        }
        fn verify_split(gb: &GroupElement, gc: &GroupElement, _gy: &GroupElement, gn: &GroupElement, pb: &Proof, pc: &Proof) -> bool {
            verify_proof(gn, gb, pb) && verify_proof(gn, gc, pc)
        }
    }

    pub type RekeyFactor = ScalarNonZero;
    pub type RekeyFactorVerifiers = PEPFactorVerifiers;

    /// Second GroupElement is `k*G` if prove_rekey with `k` is called.
    pub struct ProvedRekey(pub Proof, pub Proof);

    impl ProvedRekey {
        pub fn new<R: RngCore + CryptoRng>(v: &ElGamal, k: &RekeyFactor, rng: &mut R) -> Self {
            // Rekey is normally {in.b/k, in.c, k*in.y};
            let (_, pb) = create_proof(&k.invert(), &v.b, rng);
            let (_, py) = create_proof(k, &v.y, rng);
            Self(pb, py)
        }
        pub fn verified_reconstruct(&self, original: &ElGamal, verifiers: &RekeyFactorVerifiers) -> Option<ElGamal> {
            if self.verify(original, verifiers) {
                Some(self.reconstruct(original))
            } else {
                None
            }
        }
        fn reconstruct(&self, original: &ElGamal) -> ElGamal {
            ElGamal {
                b: *self.0,
                c: original.c,
                y: *self.1,
            }
        }
        fn verify(&self, original: &ElGamal, verifiers: &RekeyFactorVerifiers) -> bool {
            Self::verify_split(&original.b, &original.c, &original.y, &verifiers.0, &verifiers.1, &self.0, &self.1)
        }
        fn verify_reshuffled(&self, original: &ElGamal, new: &ElGamal, verifiers: &RekeyFactorVerifiers) -> bool {
            self.verify(original, verifiers) && new.b == self.0.n && new.c == original.c && new.y == self.1.n
        }
        fn verify_split(gb: &GroupElement, _gc: &GroupElement, gy: &GroupElement, gk: &GroupElement, gki: &GroupElement, pb: &Proof, py: &Proof) -> bool {
            verify_proof(gki, gb, pb) && verify_proof(gk, gy, py)
        }
    }

    pub struct ProvedReshuffleFromTo(pub Proof, pub Proof, pub Proof);

    impl ProvedReshuffleFromTo {
        pub fn new<R: RngCore + CryptoRng>(v: &ElGamal, n_from: &ReshuffleFactor, n_to: &ReshuffleFactor, rng: &mut R) -> Self {
            // Reshuffle is normally {n_from^-1 * n_to * in.b, n_from^-1 * n_to * in.c, in.y};
            // NOTE: can be optimised a bit, by fusing the two CreateProofs (because same n is used, saving a n*G operation)
            let n = n_from.invert() * n_to;
            let (_gn, pb) = create_proof(&n, &v.b, rng);
            let (_gn, pc) = create_proof(&n, &v.c, rng);
            let (_gn_to, pn) = create_proof(n_to, &(n_from.invert() * G), rng);
            Self(pb, pc, pn)
        }
        pub fn verified_reconstruct(&self, original: &ElGamal, verifiers_from: &ReshuffleFactorVerifiers, verifiers_to: &ReshuffleFactorVerifiers) -> Option<ElGamal> {
            if self.verify(original, verifiers_from, verifiers_to) {
                Some(self.reconstruct(original))
            } else {
                None
            }
        }
        fn reconstruct(&self, original: &ElGamal) -> ElGamal {
            ElGamal {
                b: *self.0,
                c: *self.1,
                y: original.y,
            }
        }
        fn verify(&self, original: &ElGamal, verifiers_from: &ReshuffleFactorVerifiers, verifiers_to: &ReshuffleFactorVerifiers) -> bool {
            Self::verify_split(&original.b, &original.c, &original.y, &verifiers_from.1, &verifiers_to.0, &self.0, &self.1, &self.2)
        }
        fn verify_reshuffled_from_to(&self, original: &ElGamal, new: &ElGamal, verifiers_from: &ReshuffleFactorVerifiers, verifiers_to: &ReshuffleFactorVerifiers) -> bool {
            self.verify(original, verifiers_from, verifiers_to) && new.b == self.0.n && new.c == self.1.n && new.y == original.y
        }
        fn verify_split(gb: &GroupElement, gc: &GroupElement, _gy: &GroupElement, gn_from_inv: &GroupElement, gn_to: &GroupElement, pb: &Proof, pc: &Proof, pn: &Proof) -> bool {
            // pn is needed as proof that n is constructed as n_from.invert() * n_t
            verify_proof(&pn.n, gb, pb) && verify_proof(&pn.n, gc, pc) && verify_proof(gn_to, gn_from_inv, pn)
        }
    }

    pub struct ProvedRSK(pub Proof, pub Proof, pub Proof, pub Proof);

    impl ProvedRSK {
        pub fn new<R: RngCore + CryptoRng>(v: &ElGamal, n: &ReshuffleFactor, k: &RekeyFactor, rng: &mut R) -> Self {
            // RSK is normally {n * k^-1 * in.b, n * in.c, k * in.y};
            let ki = k.invert();
            let nki = n * ki;
            let (_gm, pnki) = create_proof(&ki, &(n * G), rng);
            let (_gnki, pb) = create_proof(&nki, &v.b, rng);
            let (_gn, pc) = create_proof(&n, &v.c, rng);
            let (_gk, py) = create_proof(k, &v.y, rng);
            Self(pb, pc, py, pnki)
        }
        pub fn verified_reconstruct(&self, original: &ElGamal, reshuffle_verifiers: &ReshuffleFactorVerifiers, rekey_verifiers: &RekeyFactorVerifiers) -> Option<ElGamal> {
            if self.verify(original, reshuffle_verifiers, rekey_verifiers) {
                Some(self.reconstruct())
            } else {
                None
            }
        }
        fn reconstruct(&self) -> ElGamal {
            ElGamal {
                b: *self.0,
                c: *self.1,
                y: *self.2,
            }
        }
        fn verify(&self, original: &ElGamal, reshuffle_verifiers: &ReshuffleFactorVerifiers, rekey_verifiers: &RekeyFactorVerifiers) -> bool {
            Self::verify_split(&original.b, &original.c, &original.y, &reshuffle_verifiers.0, &rekey_verifiers.0, &rekey_verifiers.1, &self.0, &self.1, &self.2, &self.3)
        }
        fn verify_rskd(&self, original: &ElGamal, new: &ElGamal, reshuffle_verifiers: &ReshuffleFactorVerifiers, rekey_verifiers: &RekeyFactorVerifiers) -> bool {
            self.verify(original, reshuffle_verifiers, rekey_verifiers) && new.b == self.0.n && new.c == self.1.n && new.y == self.2.n
        }
        fn verify_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gn: &GroupElement, gk: &GroupElement, gki: &GroupElement, pb: &Proof, pc: &Proof, py: &Proof, pnki: &Proof) -> bool {
            verify_proof(&pnki.n, gb, pb) && verify_proof(gn, gc, pc) && verify_proof(gk, gy, py) && verify_proof(gki, gn, pnki)
        }
    }

    pub struct ProvedRSKFromTo(pub Proof, pub Proof, pub Proof, pub Proof, pub Proof);

    impl ProvedRSKFromTo {
        pub fn new<R: RngCore + CryptoRng>(v: &ElGamal, n_from: &ReshuffleFactor, n_to: &ReshuffleFactor, k: &RekeyFactor, rng: &mut R) -> Self {
            // RSK is normally {n * k^-1 * in.b, n * in.c, k * in.y};
            let n_from_inv = n_from.invert();
            let n = n_from_inv * n_to;
            let ki = k.invert();
            let nki = n * ki;
            let (_gn_from_inv, pn) = create_proof(&n_from_inv, &(n_to * G), rng);
            let (_gm, pnki) = create_proof(&ki, &pn.n, rng);
            let (_gnki, pb) = create_proof(&nki, &v.b, rng);
            let (_gn, pc) = create_proof(&n, &v.c, rng);
            let (_gk, py) = create_proof(k, &v.y, rng);
            Self(pb, pc, py, pnki, pn)
        }
        pub fn verified_reconstruct(&self, original: &ElGamal, reshuffle_verifiers_from: &ReshuffleFactorVerifiers, reshuffle_verifiers_to: &ReshuffleFactorVerifiers, rekey_verifiers: &RekeyFactorVerifiers) -> Option<ElGamal> {
            if self.verify(original, reshuffle_verifiers_from, reshuffle_verifiers_to, rekey_verifiers) {
                Some(self.reconstruct())
            } else {
                None
            }
        }
        fn reconstruct(&self) -> ElGamal {
            ElGamal {
                b: *self.0,
                c: *self.1,
                y: *self.2,
            }
        }
        fn verify(&self, original: &ElGamal, reshuffle_verifiers_from: &ReshuffleFactorVerifiers, reshuffle_verifiers_to: &ReshuffleFactorVerifiers, rekey_verifiers: &RekeyFactorVerifiers) -> bool {
            Self::verify_split(&original.b, &original.c, &original.y, &reshuffle_verifiers_from.1, &reshuffle_verifiers_to.0, &rekey_verifiers.0, &rekey_verifiers.1, &self.0, &self.1, &self.2, &self.3, &self.4)
        }
        fn verify_rskd_from_to(&self, original: &ElGamal, new: &ElGamal, reshuffle_verifiers_from: &ReshuffleFactorVerifiers, reshuffle_verifiers_to: &ReshuffleFactorVerifiers, rekey_verifiers: &RekeyFactorVerifiers) -> bool {
            self.verify(original, reshuffle_verifiers_from, reshuffle_verifiers_to, rekey_verifiers) && new.b == self.0.n && new.c == self.1.n && new.y == self.2.n
        }
        fn verify_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gn_from_inv: &GroupElement, gn_to: &GroupElement, gk: &GroupElement, gki: &GroupElement, pb: &Proof, pc: &Proof, py: &Proof, pnki: &Proof, pn: &Proof) -> bool {
            verify_proof(&pnki.n, gb, pb) && verify_proof(&pn.n, gc, pc) && verify_proof(gk, gy, py) && verify_proof(gki, &pn.n, pnki) && verify_proof(gn_from_inv, &gn_to, pn)
        }
    }

    pub fn prove_rerandomize<R: RngCore + CryptoRng>(v: &ElGamal, s: &ScalarNonZero, rng: &mut R) -> ProvedRerandomize {
        ProvedRerandomize::new(v, s, rng)
    }

    pub fn prove_reshuffle<R: RngCore + CryptoRng>(v: &ElGamal, n: &ReshuffleFactor, rng: &mut R) -> ProvedReshuffle {
        ProvedReshuffle::new(v, n, rng)
    }

    pub fn prove_rekey<R: RngCore + CryptoRng>(v: &ElGamal, k: &RekeyFactor, rng: &mut R) -> ProvedRekey {
        ProvedRekey::new(v, k, rng)
    }

    pub fn prove_reshuffle_from_to<R: RngCore + CryptoRng>(v: &ElGamal, n_from: &ReshuffleFactor, n_to: &ReshuffleFactor, rng: &mut R) -> ProvedReshuffleFromTo {
        ProvedReshuffleFromTo::new(v, n_from, n_to, rng)
    }

    pub fn prove_rsk<R: RngCore + CryptoRng>(v: &ElGamal, n: &ReshuffleFactor, k: &RekeyFactor, rng: &mut R) -> ProvedRSK {
        ProvedRSK::new(v, n, k, rng)
    }

    pub fn prove_rsk_from_to<R: RngCore + CryptoRng>(v: &ElGamal, n_from: &ReshuffleFactor, n_to: &ReshuffleFactor, k: &RekeyFactor, rng: &mut R) -> ProvedRSKFromTo {
        ProvedRSKFromTo::new(v, n_from, n_to, k, rng)
    }
}


/// Higher lever API for simple pseudonimisation on a single host.
pub mod simple {
    use crate::*;

    type GlobalPublicKey = GroupElement;
    type GlobalSecretKey = ScalarNonZero;
    type GlobalEncryptedPseudonym = ElGamal;
    type LocalEncryptedPseudonym = ElGamal;
    type LocalPseudonym = GroupElement;
    type LocalDecryptionKey = ScalarNonZero;

    pub fn generate_global_keys<R: RngCore + CryptoRng>(rng: &mut R) -> (GlobalPublicKey, GlobalSecretKey) {
        // secret key of system
        let y = ScalarNonZero::random(rng);
        // public key of system
        let gy = y * G;
        (gy, y)
    }

    /// Generates a non-zero scalar.
    fn make_factor(typ: &str, secret: &str, context: &str) -> ScalarNonZero {
        let mut hasher = Sha512::default();
        hasher.update(typ.as_bytes());
        hasher.update(b"|");
        hasher.update(secret.as_bytes());
        hasher.update(b"|");
        hasher.update(context.as_bytes());
        let mut bytes = [0u8; 64];
        bytes.copy_from_slice(hasher.finalize().as_slice());
        ScalarNonZero::from_hash(&bytes)
    }

    /// Generates a non-zero scalar.
    pub(crate) fn make_pseudonymisation_factor(secret: &str, context: &str) -> ScalarNonZero {
        make_factor("pseudonym", secret, context)
    }

    /// Generates a non-zero scalar.
    pub fn make_decryption_factor(secret: &str, context: &str) -> ScalarNonZero {
        make_factor("decryption", secret, context)
    }

    /// Generates a encrypted global pseudonym by encrypting a text with ElGamal using the global
    /// public key `pkg`.
    pub fn generate_pseudonym<R: RngCore + CryptoRng>(identity: &str, pk: &GlobalPublicKey, rng: &mut R) -> GlobalEncryptedPseudonym {
        let mut hasher = Sha512::default();
        hasher.update(identity.as_bytes());
        let mut bytes = [0u8; 64];
        bytes.copy_from_slice(hasher.finalize().as_slice());
        let p = GroupElement::from_hash(&bytes);
        encrypt(&p, pk, rng)
    }

    /// Using a PEP `rks` operation, convert a global encrypted pseudonym to a local encrypted pseudonym,
    /// which is:
    /// - decryptable with the key `k` that is generated by [make_local_decryption_key] using the same
    ///   `decryption_context`;
    /// - decrypts to the pseudonym that is the global pseudonym multiplied by a factor specific to the
    ///   `pseudonimisation_context`.
    pub fn convert_to_local_pseudonym(p: &GlobalEncryptedPseudonym, secret: &str, decryption_context: &str, pseudonimisation_context: &str) -> LocalEncryptedPseudonym {
        let u = make_pseudonymisation_factor(secret, pseudonimisation_context);
        let t = make_decryption_factor(secret, decryption_context);
        rsk(p, &u, &t)
    }

    pub fn convert_from_local_pseudonym(p: &LocalEncryptedPseudonym, secret: &str, decryption_context: &str, pseudonimisation_context: &str) -> GlobalEncryptedPseudonym {
        let u = make_pseudonymisation_factor(secret, pseudonimisation_context).invert();
        let t = make_decryption_factor(secret, decryption_context).invert();
        rsk(p, &u, &t)
    }

    pub fn make_local_decryption_key(k: &GlobalSecretKey, secret: &str, decryption_context: &str) -> LocalDecryptionKey {
        let t = make_decryption_factor(secret, decryption_context);
        t * k
    }

    pub fn decrypt_local_pseudonym(p: &LocalEncryptedPseudonym, k: &LocalDecryptionKey) -> LocalPseudonym {
        decrypt(p, k)
    }

    pub fn rerandomize_global<R: RngCore + CryptoRng>(p: &GlobalEncryptedPseudonym, rng: &mut R) -> GlobalEncryptedPseudonym {
        rerandomize(p, &ScalarNonZero::random(rng))
    }

    pub fn rerandomize_local<R: RngCore + CryptoRng>(p: &LocalEncryptedPseudonym, rng: &mut R) -> LocalEncryptedPseudonym {
        rerandomize(p, &ScalarNonZero::random(rng))
    }
}

pub mod distributed {
    use std::collections::HashMap;
    use crate::*;
    use crate::zkp::*;
    use crate::simple::*;

    pub type GlobalPublicKey = GroupElement;
    pub type GlobalSecretKey = ScalarNonZero;
    pub type BlindedGlobalSecretKey = ScalarNonZero;
    pub type DecryptionKeyPart = ScalarNonZero;
    pub type DecryptionKey = ScalarNonZero;

    pub type Message = GroupElement;
    pub type Ciphertext = ElGamal;
    pub type Context = String;
    pub type SystemId = String;

    pub struct TrustedPEPFactorVerifiersCache {
        pub cache: HashMap<(SystemId, Context), PEPFactorVerifiers>,
    }

    impl TrustedPEPFactorVerifiersCache {
        fn new() -> Self {
            TrustedPEPFactorVerifiersCache {
                cache: HashMap::new(),
            }
        }
        fn store(&mut self, system_id: SystemId, context: Context, verifiers: PEPFactorVerifiers) {
            self.cache.insert((system_id, context), verifiers);
        }
        fn retrieve(&self, system_id: &SystemId, context: &Context) -> Option<&PEPFactorVerifiers> {
            self.cache.get(&(system_id.to_string(), context.to_string()))
        }
        fn contains(&self, verifiers: &PEPFactorVerifiers) -> bool {
            self.cache.values().any(|x| x == verifiers)
        }
        fn dump(&self) -> Vec<(SystemId, Context, PEPFactorVerifiers)> {
            self.cache.iter().map(|((system_id, context), verifiers)| (system_id.clone(), context.clone(), verifiers.clone())).collect()
        }
        fn load(&mut self, data: Vec<(SystemId, Context, PEPFactorVerifiers)>) {
            for (system_id, context, verifiers) in data {
                self.store(system_id, context, verifiers);
            }
        }
    }

    pub struct PEPClient {
        // A PEPClient is a client that can verify PEP operations performed by a PEPSystem.
        pub config: PEPNetworkConfig,
        pub trusted_pseudonymisation_factors: TrustedPEPFactorVerifiersCache,
        pub trusted_rekeying_factors: TrustedPEPFactorVerifiersCache,
    }

    pub struct PEPSystem {
        // A PEPSystem is a system that can perform PEP operations on messages (and verify them).
        pub client: PEPClient,
        pub system_id: String,
        pseudonymisation_secret: String,
        rekeying_secret: String,
        blinding_factor: ScalarNonZero,
    }

    #[derive(Eq, PartialEq, Clone)]
    pub struct PEPNetworkConfig {
        // A PEPNetworkConfig is a configuration of a PEP network generated during the setup phase.
        pub global_public_key: GlobalPublicKey,
        pub blinded_global_private_key: BlindedGlobalSecretKey,
        pub system_ids: Vec<String>,
        pub blinded_global_key_group_elements: Vec<GroupElement>,
    }

    impl PEPNetworkConfig {
        pub fn new(global_public_key: GlobalPublicKey, blinded_global_private_key: BlindedGlobalSecretKey, system_ids: Vec<SystemId>, blinded_global_key_group_elements: Vec<GroupElement>) -> Self {
            Self {
                global_public_key,
                blinded_global_private_key,
                system_ids,
                blinded_global_key_group_elements,
            }
        }
    }

    impl PEPSystem {
        pub fn new(system_id: SystemId, config: PEPNetworkConfig, pseudonymisation_secret: String, rekeying_secret: String, blinding_factor: ScalarNonZero) -> Self {
            Self {
                client: PEPClient::new(config),
                system_id,
                pseudonymisation_secret,
                rekeying_secret,
                blinding_factor,
            }
        }
        pub fn pseudonymize<R: RngCore + CryptoRng>(&self, message: &Ciphertext, pc_from: &Context, pc_to: &Context, dc: &Context, rng: &mut R) -> ProvedRSKFromTo {
            let n_from = make_pseudonymisation_factor(&self.pseudonymisation_secret, pc_from);
            let n_to = make_pseudonymisation_factor(&self.pseudonymisation_secret, pc_to);
            let k = make_decryption_factor(&self.rekeying_secret, dc);
            ProvedRSKFromTo::new(message, &n_from, &n_to, &k, rng)
        }
        pub fn transcrypt<R: RngCore + CryptoRng>(&self, message: &Ciphertext, dc: &Context, rng: &mut R) -> ProvedRekey {
            let k = make_decryption_factor(&self.rekeying_secret, dc);
            ProvedRekey::new(message, &k, rng)
        }
        pub fn pseudonymisation_factor_verifiers_proof<R: RngCore + CryptoRng>(&self, pc: &Context, rng: &mut R) -> (ReshuffleFactorVerifiers, PEPFactorVerifiersProof) {
            let n = make_pseudonymisation_factor(&self.pseudonymisation_secret, pc);
            generate_pep_factor_verifiers(&n, rng)
        }
        pub fn rekeying_factor_verifiers_proof<R: RngCore + CryptoRng>(&self, dc: &Context, rng: &mut R) -> (RekeyFactorVerifiers, PEPFactorVerifiersProof) {
            let n = make_decryption_factor(&self.rekeying_secret, dc);
            generate_pep_factor_verifiers(&n, rng)
        }
        pub fn decryption_key_part<R: RngCore + CryptoRng>(&self, dc: &Context, rng: &mut R) -> (DecryptionKeyPart, Proof) {
            let k = make_decryption_factor(&self.rekeying_secret, dc);
            let dkp = k * &self.blinding_factor.invert();
            let (_gbi, proof) = create_proof(&self.blinding_factor.invert(), &(k * G), rng);
            (dkp, proof)
        }
    }

    impl PEPClient {
        pub fn new(config: PEPNetworkConfig) -> Self {
            Self {
                config,
                trusted_pseudonymisation_factors: TrustedPEPFactorVerifiersCache::new(),
                trusted_rekeying_factors: TrustedPEPFactorVerifiersCache::new(),
            }
        }
        fn verify_system_pseudonymize(&self, system_id: &SystemId, msg_in: &Ciphertext, proved: &ProvedRSKFromTo, pc_from: &Context, pc_to: &Context, dc: &Context) -> Result<Ciphertext, &'static str> {
            let trusted_from = self.trusted_pseudonymisation_factors.retrieve(system_id, pc_from).unwrap();
            let trusted_to = self.trusted_pseudonymisation_factors.retrieve(system_id, pc_to).unwrap();
            let trusted_k = self.trusted_rekeying_factors.retrieve(system_id, dc).unwrap();

            let msg_out = proved.verified_reconstruct(msg_in, trusted_from, trusted_to, trusted_k);
            if msg_out.is_none() {
                return Err("invalid proof");
            }

            Ok(msg_out.unwrap())
        }
        pub fn verify_pseudonymize(&self, messages: &Vec<(String, ElGamal, ProvedRSKFromTo)>, pc_from: &Context, pc_to: &Context, dc: &Context) -> Result<Ciphertext, &'static str> {
            let mut msg_out = None;
            let mut visited_systems = Vec::new();
            for (system_id, msg_in, proved) in messages {
                if !self.config.system_ids.contains(&String::from(system_id)) {
                    return Err("invalid system id");
                }
                if visited_systems.contains(&system_id) {
                    return Err("system visited twice");
                }
                if msg_out.is_some() && msg_out.unwrap() != *msg_in {
                    return Err("inconsistent messages");
                }
                let verification = self.verify_system_pseudonymize(&system_id, &msg_in, proved, pc_from, pc_to, dc);
                if verification.is_err() {
                    return verification;
                }
                msg_out = Some(verification.unwrap());
                visited_systems.push(system_id);
            }
            Ok(msg_out.unwrap())
        }
        fn verify_system_transcrypt(&self, system_id: &SystemId, msg_in: &Ciphertext, proved_rekey: &ProvedRekey, dc: &Context) -> Result<Ciphertext, &'static str> {
            let trusted_k = self.trusted_rekeying_factors.retrieve(system_id, dc).unwrap();

            let msg_out = proved_rekey.verified_reconstruct(msg_in, trusted_k);
            if msg_out.is_none() {
                return Err("invalid proof");
            }
            Ok(msg_out.unwrap())
        }
        pub fn verify_transcrypt(&self, messages: &Vec<(String, ElGamal, ProvedRekey)>, dc: &Context) -> Result<Ciphertext, &'static str> {
            let mut msg_out = None;
            let mut visited_systems = Vec::new();
            for (system_id, msg_in, proved) in messages {
                if !self.config.system_ids.contains(&String::from(system_id)) {
                    return Err("invalid system id");
                }
                if visited_systems.contains(&system_id) {
                    return Err("system visited twice");
                }
                if msg_out.is_some() && msg_out.unwrap() != *msg_in {
                    return Err("inconsistent messages");
                }
                let verification = self.verify_system_transcrypt(&system_id, &msg_in, &proved, dc);
                if verification.is_err() {
                    return verification;
                }
                msg_out = Some(verification.unwrap());
                visited_systems.push(system_id);
            }
            Ok(msg_out.unwrap())
        }
        pub fn trust_pseudonymisation_factor_verifiers(&mut self, system_id: &SystemId, pc: &Context, verifiers: &ReshuffleFactorVerifiers, proof: &PEPFactorVerifiersProof) {
            assert!(verify_pep_factor_verifiers(&verifiers, &proof));
            self.trusted_pseudonymisation_factors.store(system_id.to_string(), pc.to_string(), *verifiers);
        }
        pub fn trust_rekeying_factor_verifiers(&mut self, system_id: &SystemId, dc: &Context, verifiers: &RekeyFactorVerifiers, proof: &PEPFactorVerifiersProof) {
            assert!(verify_pep_factor_verifiers(&verifiers, &proof));
            self.trusted_rekeying_factors.store(system_id.to_string(), dc.to_string(), *verifiers);
        }

        #[must_use]
        pub fn verify_decryption_key_part(&self, dkp: &DecryptionKeyPart, system_id: &SystemId, dc: &Context, proof: &Proof) -> bool {
            let gk = self.trusted_rekeying_factors.retrieve(system_id, dc).unwrap().0;
            let blinded_global_key_group_element = self.config.blinded_global_key_group_elements[self.config.system_ids.iter().position(|x| x == system_id).unwrap()];
            verify_proof(&blinded_global_key_group_element, &gk, proof) && proof.n == *dkp * G
        }
        #[must_use]
        pub fn verify_decryption_key_parts(&self, dkps: &Vec<(SystemId, (DecryptionKeyPart, Proof))>, dc: &Context) -> bool {
            for (sid, (dkp, proof)) in dkps {
                assert!(self.verify_decryption_key_part(&dkp, &sid, dc, &proof));
            }
            true
        }
        pub fn decryption_key(&self, dkps: &Vec<(SystemId, (DecryptionKeyPart, Proof))>, dc: &Context) -> Option<DecryptionKey> {
            if self.verify_decryption_key_parts(dkps, dc) {
                Some(dkps.iter().fold(self.config.blinded_global_private_key, |acc, (_sid, (dkp, _p))| acc * dkp))
            } else {
                None
            }
        }
        pub fn decrypt(&self, msg: &Ciphertext, dkps: &Vec<(SystemId, (DecryptionKeyPart, Proof))>, dc: &Context) -> Message {
            let dk = self.decryption_key(dkps, dc).unwrap();
            decrypt(msg, &dk)
        }
        pub fn encrypt<R: RngCore + CryptoRng>(&self, msg: &Message, rng: &mut R) -> Ciphertext {
            // Note this is the only operation that requires a random number generator
            // If the ciphertext cannot securely generate ciphertexts, the network should rerandomize the ciphertexts to prevent linkability
            encrypt(msg, &self.config.global_public_key, rng)
        }
    }
}

#[cfg(test)]
mod libpep {
    use crate::*;
    use crate::zkp::*;
    use crate::simple::*;
    use crate::distributed::*;
    use rand_core::OsRng;

    #[test]
    fn elgamal_encryption() {
        let mut rng = OsRng;
        // secret key
        let s = ScalarNonZero::random(&mut rng);
        // public key
        let p = s * G;

        // choose a random value to encrypt
        let value = GroupElement::random(&mut rng);

        // encrypt/decrypt this value
        let encrypted = encrypt(&value, &p, &mut OsRng);
        let decrypted = decrypt(&encrypted, &s);

        assert_eq!(value, decrypted);


        let encoded = encrypted.encode();
        let decoded = ElGamal::decode(&encoded);

        assert_eq!(Some(encrypted), decoded);
    }

    #[test]
    fn pep_assumptions() {
        let mut rng = OsRng;
        // secret key of system
        let sk = ScalarNonZero::random(&mut rng);
        // public key of system
        let pk = sk * G;

        // secret key of service provider
        let sj = ScalarNonZero::random(&mut rng);
        let yj = sj * sk;
        assert_eq!(yj * G, sj * pk);

        // Lemma 2: RS(RK(..., k), n) == RK(RS(..., n), k)
        let value = GroupElement::random(&mut rng);
        let encrypted = encrypt(&value, &pk, &mut OsRng);
        let k = ScalarNonZero::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);
        assert_eq!(reshuffle(&rekey(&encrypted, &k), &n), rekey(&reshuffle(&encrypted, &n), &k));
        assert_eq!(reshuffle(&rekey(&encrypted, &k), &n), rsk(&encrypted, &n, &k));
    }

    #[test]
    fn elgamal_signature() {
        let mut rng = OsRng;
        // secret key
        let s = ScalarNonZero::random(&mut rng);
        let s2 = ScalarNonZero::random(&mut rng);
        // public key
        let gp = s * G;

        let v = GroupElement::random(&mut rng);
        let mut signature = sign(&v, &s, &mut rng);
        assert!(verify(&v, &signature, &gp));

        signature = sign(&v, &s2, &mut rng);
        assert!(!verify(&v, &signature, &gp));
    }

    #[test]
    fn pep_schnorr_basic_offline() {
        let mut rng = OsRng;
        // given a secret a and public M, proof that a certain triplet (A, M, N) is actually calculated by (a*G, M, a * M)
        // using Fiat-Shamir transform

        // prover
        let a = ScalarNonZero::random(&mut rng);
        let gm = GroupElement::random(&mut rng);

        let (ga, p) = create_proof(&a, &gm, &mut rng);
        assert_eq!(a * gm, *p);

        // verifier
        assert!(verify_proof(&ga, &gm, &p));
    }

    #[test]
    fn pep_factor_verifiers_proof() {
        let mut rng = OsRng;

        let x = ScalarNonZero::random(&mut rng);
        let (verifiers, proof) = generate_pep_factor_verifiers(&x, &mut rng);
        assert!(verify_pep_factor_verifiers(&verifiers, &proof));
    }

    #[test]
    fn pep_proved_rerandomize() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y * G;

        let gm = GroupElement::random(&mut rng);
        let s = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = ProvedRerandomize::new(&msg, &s, &mut rng);

        let checked = proved.verified_reconstruct(&msg);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&rerandomize(&msg, &s), checked.as_ref().unwrap());
    }

    #[test]
    fn pep_proved_reshuffle() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y * G;

        let gm = GroupElement::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);

        let (verifiers, _) = generate_pep_factor_verifiers(&n, &mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = ProvedReshuffle::new(&msg, &n, &mut rng);

        let checked = proved.verified_reconstruct(&msg, &verifiers);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(n * gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&reshuffle(&msg, &n), checked.as_ref().unwrap());
    }

    #[test]
    fn pep_proved_rekey() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y * G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);

        let (verifiers, _) = generate_pep_factor_verifiers(&k, &mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = ProvedRekey::new(&msg, &k, &mut rng);
        let checked = proved.verified_reconstruct(&msg, &verifiers);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(gm, decrypt(checked.as_ref().unwrap(), &(k * y)));
    }

    #[test]
    fn pep_proved_reshuffle_from_to() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y * G;

        let gm = GroupElement::random(&mut rng);
        let n_from = ScalarNonZero::random(&mut rng);
        let n_to = ScalarNonZero::random(&mut rng);

        let (verifiers_from, _) = generate_pep_factor_verifiers(&n_from, &mut rng);
        let (verifiers_to, _) = generate_pep_factor_verifiers(&n_to, &mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = ProvedReshuffleFromTo::new(&msg, &n_from, &n_to, &mut rng);

        let checked = proved.verified_reconstruct(&msg, &verifiers_from, &verifiers_to);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(n_from.invert() * n_to * gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&reshuffle_from_to(&msg, &n_from, &n_to), checked.as_ref().unwrap());
    }
    #[test]
    fn pep_proved_rsk() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y * G;

        let gm = GroupElement::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);

        let (verifiers_n, _) = generate_pep_factor_verifiers(&n, &mut rng);
        let (verifiers_k, _) = generate_pep_factor_verifiers(&k, &mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = ProvedRSK::new(&msg, &n, &k, &mut rng);

        let checked = proved.verified_reconstruct(&msg, &verifiers_n, &verifiers_k);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(n * gm, decrypt(checked.as_ref().unwrap(), &(k * y)));
        assert_eq!(&rsk(&msg, &n, &k), checked.as_ref().unwrap());
    }
    #[test]
    fn pep_proved_rsk_from_to() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y * G;

        let gm = GroupElement::random(&mut rng);
        let n_from = ScalarNonZero::random(&mut rng);
        let n_to = ScalarNonZero::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);

        let (verifiers_from, _) = generate_pep_factor_verifiers(&n_from, &mut rng);
        let (verifiers_to, _) = generate_pep_factor_verifiers(&n_to, &mut rng);
        let (verifiers_k, _) = generate_pep_factor_verifiers(&k, &mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = ProvedRSKFromTo::new(&msg, &n_from, &n_to, &k, &mut rng);

        let checked = proved.verified_reconstruct(&msg, &verifiers_from, &verifiers_to, &verifiers_k);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(n_from.invert() * n_to * gm, decrypt(checked.as_ref().unwrap(), &(k * y)));
        assert_eq!(&rsk_from_to(&msg, &n_from, &n_to, &k), checked.as_ref().unwrap());
    }

    #[test]
    fn pep_high_level_api() {
        let mut rng = OsRng;
        let (public_key, secret_key) = generate_global_keys(&mut rng);

        let id = "foobar";
        let mut gep = generate_pseudonym(id, &public_key, &mut rng);
        gep = rerandomize_global(&gep, &mut rng);
        let mut lep = convert_to_local_pseudonym(&gep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        lep = rerandomize_local(&lep, &mut rng);

        let decryption_key = make_local_decryption_key(&secret_key, "very_secret_on_server", "login_session_of_user");
        let lp = decrypt_local_pseudonym(&lep, &decryption_key);
        let hex = "be26a708fcf722db8d19f6d8c8443794156af30b17c44bcf4bb41791c0708945";
        let expected = hex::decode(hex).unwrap();
        assert_eq!(&lp.encode()[..], &expected);

        let gep = convert_from_local_pseudonym(&lep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        let mut lep = convert_to_local_pseudonym(&gep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        lep = rerandomize_local(&lep, &mut rng);

        let decryption_key = make_local_decryption_key(&secret_key, "very_secret_on_server", "login_session_of_user");
        let lp = decrypt_local_pseudonym(&lep, &decryption_key);
        let hex = "be26a708fcf722db8d19f6d8c8443794156af30b17c44bcf4bb41791c0708945";
        let expected = hex::decode(hex).unwrap();
        assert_eq!(&lp.encode()[..], &expected);
    }

    #[test]
    fn distributed_pep_api() {
        let n = 5;
        let mut rng = OsRng;

        fn setup_network<R: RngCore + CryptoRng>(n: usize, rng: &mut R) -> (PEPNetworkConfig, Vec<PEPSystem>, Vec<String>, Vec<String>, Vec<(ScalarNonZero, GroupElement)>) {
            let (global_public_key, global_secret_key) = generate_global_keys(rng);

            let mut blinding_factors = Vec::new();
            for _ in 0..n {
                let blinding_factor = ScalarNonZero::random(rng);
                let blinding_inv_group_element = blinding_factor.invert() * G;
                blinding_factors.push((blinding_factor, blinding_inv_group_element));
            }
            let blinded_global_secret_key = blinding_factors.iter().fold(global_secret_key, |acc, s| acc * s.0);
            let blinding_inv_group_elements: Vec<GroupElement> = blinding_factors.iter().map(|x| x.1).collect();
            // TODO: we can add proofs that the blinding factors are correct to get even more trust during system setup
            // TODO: we could even hide them with secondary blinding factor, only used for constructing blinded_global_secret_key

            let network_config = PEPNetworkConfig::new(global_public_key, blinded_global_secret_key, (0..n).map(|i| format!("system-{}", i)).collect(), blinding_inv_group_elements.clone());

            let mut pseudonymisation_secrets = Vec::new();
            let mut rekeying_secrets = Vec::new();
            let mut systems = Vec::new();
            for i in 0..n {
                let system_id: SystemId = format!("system-{}", i);
                let pseudonymisation_secret = hex::encode(&ScalarNonZero::random(rng).encode());
                pseudonymisation_secrets.push(pseudonymisation_secret.clone());
                let rekeying_secret = hex::encode(&ScalarNonZero::random(rng).encode());
                rekeying_secrets.push(rekeying_secret.clone());
                let system = PEPSystem::new(system_id, network_config.clone(), pseudonymisation_secret, rekeying_secret, blinding_factors[i].0);
                systems.push(system);
            }

            (network_config, systems, pseudonymisation_secrets, rekeying_secrets, blinding_factors) // secrets are only returned for testing
        }


        fn retrieve_factor_verifiers(systems: &mut Vec<PEPSystem>, user: &mut PEPClient, pc_from: &Context, pc_to: &Context, dc: &Context, rng: &mut OsRng) {
            for i in 0..systems.len() {
                let system_id = &systems[i].system_id.clone();
                let (v_pc_from, p_pc_from) = systems[i].pseudonymisation_factor_verifiers_proof(&pc_from, rng);
                let (v_pc_to, p_pc_to) = systems[i].pseudonymisation_factor_verifiers_proof(&pc_to, rng);
                let (v_dc, p_dc) = systems[i].rekeying_factor_verifiers_proof(&dc, rng);

                for j in 0..systems.len() {
                    let system = &mut systems[j];
                    if i == j {
                        continue;
                    }
                    system.client.trust_pseudonymisation_factor_verifiers(&system_id, &pc_from, &v_pc_from, &p_pc_from);
                    system.client.trust_pseudonymisation_factor_verifiers(system_id, &pc_to, &v_pc_to, &p_pc_to);
                    system.client.trust_rekeying_factor_verifiers(&system_id, &dc, &v_dc, &p_dc);
                }
                user.trust_pseudonymisation_factor_verifiers(&system_id, &pc_from, &v_pc_from, &p_pc_from);
                user.trust_pseudonymisation_factor_verifiers(system_id, &pc_to, &v_pc_to, &p_pc_to);
                user.trust_rekeying_factor_verifiers(&system_id, &dc, &v_dc, &p_dc);
            }
        }

        fn pseudonymize_through_network(data_in: &GroupElement, pc_from: &Context, pc_to: &Context, dc: &Context, systems: &mut Vec<PEPSystem>, sender: &mut PEPClient, receiver: &mut PEPClient, rng: &mut OsRng) -> GroupElement {
            let mut network = Vec::new();

            let msg_in = sender.encrypt(&data_in, rng);
            // TODO: rerandomize?

            // First system
            let proven = systems[0].pseudonymize(&msg_in, pc_from, pc_to, dc, rng);
            network.push((systems[0].system_id.clone(), msg_in.clone(), proven));

            // All other systems
            for i in 1..systems.len() {
                let system = &mut systems[i];
                let msg_in = system.client.verify_pseudonymize(&network, &pc_from, &pc_to, &dc).unwrap();
                let proven = system.pseudonymize(&msg_in, pc_from, pc_to, dc, rng);
                network.push((system.system_id.clone(), msg_in.clone(), proven));
            }

            // Recipient
            let msg_out = receiver.verify_pseudonymize(&network, pc_from, pc_to, dc).unwrap(); // can be done by client
            let decryption_key_parts = systems.iter().map(|s| (s.system_id.clone(), s.decryption_key_part(dc, rng))).collect::<Vec<_>>();
            let data_out = receiver.decrypt(&msg_out, &decryption_key_parts, dc);
            data_out
        }

        fn transcrypt_through_network(data_in: &GroupElement, dc: &Context, systems: &mut Vec<PEPSystem>, sender: &mut PEPClient, receiver: &mut PEPClient, rng: &mut OsRng) -> GroupElement {
            let mut network = Vec::new();

            let msg_in = sender.encrypt(&data_in, rng);
            // TODO: rerandomize?

            let msg_in = rerandomize(&msg_in, &ScalarNonZero::random(rng));

            // First system
            let proven = systems[0].transcrypt(&msg_in, dc, rng);
            network.push((systems[0].system_id.clone(), msg_in.clone(), proven));

            // All other systems
            for i in 1..systems.len() {
                let system = &mut systems[i];
                let msg_in = system.client.verify_transcrypt(&network, &dc).unwrap();
                let proven = system.transcrypt(&msg_in, dc, rng);
                network.push((system.system_id.clone(), msg_in.clone(), proven));
            }

            // Recipient
            let msg_out = receiver.verify_transcrypt(&network, dc).unwrap(); // can be done by client
            let decryption_key_parts = systems.iter().map(|s| (s.system_id.clone(), s.decryption_key_part(dc, rng))).collect::<Vec<_>>();
            let data_out = receiver.decrypt(&msg_out, &decryption_key_parts, dc);
            data_out
        }

        let (network_config, mut systems, pseudonymisation_secrets, rekeying_secrets, blinding_factors) = setup_network(n, &mut rng);

        let mut user_a = PEPClient::new(network_config.clone());
        let mut user_b = PEPClient::new(network_config.clone());
        let mut user_c = PEPClient::new(network_config.clone());

        let pc_a: Context = Context::from("pc-user-a");
        let dc_a1: Context = Context::from("dc-user-a1");
        let pc_b: Context = Context::from("pc-user-b");
        let dc_b1: Context = Context::from("dc-user-b1");
        let dc_b2: Context = Context::from("dc-user-b2");
        let pc_c: Context = Context::from("pc-user-c");
        let dc_c1: Context = Context::from("dc-user-c1");

        let lp_a = GroupElement::random(&mut rng);
        retrieve_factor_verifiers(&mut systems, &mut user_b, &pc_a, &pc_b, &dc_b1, &mut rng);
        let lp_b = pseudonymize_through_network(&lp_a, &pc_a, &pc_b, &dc_b1, &mut systems, &mut user_a, &mut user_b, &mut rng);
        let expected = decrypt(&(0..n).fold(encrypt(&lp_a, &network_config.global_public_key, &mut rng), |acc, i| rsk(&acc, &(make_pseudonymisation_factor(&pseudonymisation_secrets[i], &pc_a).invert() * make_pseudonymisation_factor(&pseudonymisation_secrets[i], &pc_b)), &make_decryption_factor(&rekeying_secrets[i], &dc_b1))), &(0..n).fold(network_config.blinded_global_private_key, |acc, i| acc * make_decryption_factor(&rekeying_secrets[i], &dc_b1) * &blinding_factors[i].0.invert()));
        assert_eq!(expected, lp_b);

        // Pseudonymization is invertible
        retrieve_factor_verifiers(&mut systems, &mut user_a, &pc_b, &pc_a, &dc_a1, &mut rng);
        let lp_a_return = pseudonymize_through_network(&lp_b, &pc_b, &pc_a, &dc_a1, &mut systems, &mut user_b, &mut user_a, &mut rng);
        assert_eq!(lp_a, lp_a_return);

        // Pseudonymization is transitive
        retrieve_factor_verifiers(&mut systems, &mut user_c, &pc_a, &pc_c, &dc_c1, &mut rng);
        let lp_c = pseudonymize_through_network(&lp_a, &pc_a, &pc_c, &dc_c1, &mut systems, &mut user_a, &mut user_c, &mut rng);
        retrieve_factor_verifiers(&mut systems, &mut user_c, &pc_b, &pc_c, &dc_c1, &mut rng);
        let lp_c_via_b = pseudonymize_through_network(&lp_b, &pc_b, &pc_c, &dc_c1, &mut systems, &mut user_b, &mut user_c, &mut rng);
        assert_eq!(lp_c, lp_c_via_b);

        // Pseudonymization is deterministic for user
        retrieve_factor_verifiers(&mut systems, &mut user_b, &pc_a, &pc_b, &dc_b2, &mut rng);
        let lp_b_2 = pseudonymize_through_network(&lp_a, &pc_a, &pc_b, &dc_b2, &mut systems, &mut user_a, &mut user_b, &mut rng);
        assert_eq!(lp_b, lp_b_2);
        assert_ne!(lp_b, lp_c);

        let plaintext_a = GroupElement::random(&mut rng);
        let plaintext_b = transcrypt_through_network(&plaintext_a, &dc_b1, &mut systems, &mut user_a, &mut user_b, &mut rng);
        assert_eq!(plaintext_a, plaintext_b);

        // Network is commutative
        systems.reverse();
        let lp_b_reversed = pseudonymize_through_network(&lp_a, &pc_a, &pc_b, &dc_b1, &mut systems, &mut user_a, &mut user_b, &mut rng);
        assert_eq!(lp_b, lp_b_reversed);
    }
}
