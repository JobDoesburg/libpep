//! This library implements the PEP encryption based on ElGamal, and operations on these encrypted messages. A message [GroupElement] `M` can be encrypted for a receiver which has public key [GroupElement] `Y` associated with it, belonging to secret key [ScalarNonZero] `y`. This encryption is random: a different random [ScalarNonZero] `r` can be used during encryption for a specific public key, resulting in different ciphertexts (encrypted messages) but decryptable by only knowing the secret key. We represent this encryption function as `EG(r, M, Y)`, which is implemented in Rust as [encrypt]. Encrypted messages `msg` are often pseudonyms or AES keys (see below).
//!
//! [ElGamal] ciphertext on which the three PEP operations can be performed:
//! - [rerandomize] by [ScalarNonZero] `s`: change encrypted representation, same contents when decrypted;
//! - [reshuffle] by [ScalarNonZero] `n`: change encrypted representation so that is has different contents when decrypted equal to `n*msg`, if the original encrypted message was [GroupElement] `msg`.
//! - [rekey] by [ScalarNonZero] `k`: change encrypted representation, so it can be decrypted by a different key `k*y` if the input can be decrypted by [ScalarNonZero] `y`.
//!
//! There are also zero knowledge proof version of these operations in module [zkp]. These are needed so that a party can prove to another party that it has applied the operation on the input data, without revealing the factors used in the operation.
//!
//! When distributing trust over multiple central servers, these zero knowledge proofs are essential, so that a malfunctioning server can not violate security guarantees of the system. For example, if reshuffling by `n` a pseudonym on a server, the requestor wants to make sure that the sent over pseudonym is actually reshuffled using the correct factor `n`, instead of a random other pseudonym or a different factor.
//!
//! Same library in different languages:
//! - [libpep-cpp](https://github.com/bvgastel/libpep-cpp) (C++);
//! - [libpep on crates.io](https://crates.io/crates/libpep) (Rust).
//!
//! ## Applications
//!
//! For **pseudonimisation**, the core operation is [reshuffle] with `n`. It modifies a main pseudonym with a factor `n` that is specific to a user (or user group) receiving the pseudonym. After applying a user specific factor `n`, a pseudonym is called a *local pseudonym*. The factor `n` is typically tied to the *access group of a user*.
//! 
//! Using only a reshuffle is insufficient, as the pseudonym is still encrypted with the public key `Y` (which can be decrypted by the secret key `y`). To allow a user to decrypt the encrypted pseudonym, a [rekey] with `k` is needed, in combination with a protocol to hand the user the secret key `k*y`. The factor `k` is typically tied to the *current session of a user*.
//!
//! To make pseudonyms harder to trace, [rerandomize] is applied frequently. This way a binary compare of the encrypted pseudonym will not leak any information.
//!
//! For **data protection**, the [rekey] operation described above allows a [GroupElement] `msg` to be
//! decryptable with another key but decryption results in the same original GroupElement `msg`. This GroupElement
//! can be used as an AES key to encrypt a larger message. Care must be taken that such an AES key is
//! not functioning as a defacto global identifier.
//!
//! ## Implementation
//!
//! This library is using the Ristretto encoding on Curve25519, implemented in the curve25519-dalek crate. There are a number of arithmetic rules for scalars and group elements: group elements can be added and subtracted from each other. Scalars support addition, subtraction, and multiplication. Division can be done by multipling with the inverse (using `s.invert()` for non-zero scalar `s`). A scalar can be converted to a group element (by multiplying with the special generator `G`), but not the other way around. Group elements can also be multiplied by a scalar.
//! 
//! Group elements have an *almost* 32 byte range (top bit is always zero, and some other values are invalid). Therefore, not all AES-256 keys (using the full 32 bytes range) are valid group elements. But all group elements are valid AES-256 keys. Group elements can be generated by [GroupElement::random] or [GroupElement::from_hash]. Scalars are also 32 bytes, and can be generated with [ScalarNonZero::random] or [ScalarNonZero::from_hash].
//!
//! The zero knowledge proofs are offline Schnorr proofs, based on a Fiat-Shamir transform. The hashing algorithm used is SHA512.
use curve25519_dalek::ristretto::RistrettoPoint;
use curve25519_dalek::ristretto::CompressedRistretto;
use curve25519_dalek::traits::Identity;
extern crate rand_core;
extern crate sha2;
use rand::CryptoRng;
use rand::RngCore;
use sha2::{Sha512, Digest};

/// Constant so that a [ScalarNonZero]/[ScalarCanBeZero] s can be converted to a [GroupElement] by performing `s * G`.
const G: GroupElement = GroupElement(curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT);

/// Returned if a zero scalar is inverted (which is similar to why a division by zero is not
/// possible).
#[derive(Debug)]
pub struct ZeroArgumentError;

/// Element on a group. Can not be converted to a scalar. Supports addition and substraction. Multiplication by a scalar is supported.
#[derive(Copy,Clone,Eq,PartialEq,Debug)]
pub struct GroupElement(RistrettoPoint);

impl GroupElement {
    pub fn encode(&self) -> [u8; 32] {
        self.0.compress().0
    }

    pub fn decode_from_slice(v: &[u8]) -> Option<Self> {
        if v.len() != 32 {
            None
        } else {
            CompressedRistretto::from_slice(v).decompress().map(Self)
        }
    }

    pub fn decode(v: [u8; 32]) -> Option<Self> {
        CompressedRistretto(v).decompress().map(Self)
    }
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        Self(RistrettoPoint::random(rng))
    }
    pub fn from_hash(v: &[u8; 64]) -> Self {
        Self(RistrettoPoint::from_uniform_bytes(v))
    }

    pub fn identity() -> Self {
        Self(RistrettoPoint::identity())
    }
}

/// Scalar, always non-zero. Can be converted to a GroupElement. Supports multiplication, and inversion (so division is possible). For addition and substraction, use [ScalarCanBeZero].
#[derive(Copy,Clone,Eq,PartialEq,Debug)]
pub struct ScalarNonZero(curve25519_dalek::scalar::Scalar);

impl ScalarNonZero {
    /// Always return a non-zero scalar.
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        loop {
            let retval = curve25519_dalek::scalar::Scalar::random(rng);
            if !retval.as_bytes().iter().all(|x| *x == 0) {
                return Self(retval);
            }
        }
    }

    pub fn from_hash(v: &[u8; 64]) -> Self {
        let retval = curve25519_dalek::scalar::Scalar::from_bytes_mod_order_wide(v);
        if retval.as_bytes().iter().all(|x| *x == 0) {
            Self(curve25519_dalek::scalar::Scalar::one())
        } else {
            Self(retval)
        }
    }

    pub fn one() -> Self {
        Self(curve25519_dalek::scalar::Scalar::one())
    }

    pub fn invert(&self) -> Self {
        Self(self.0.invert())
    }
}

/// Scalar, can be zero. Can be converted to a GroupElement. Supports multiplication, inversion (so division is possible), addition and substraction.
#[derive(Copy,Clone,Eq,PartialEq,Debug)]
pub struct ScalarCanBeZero(curve25519_dalek::scalar::Scalar);

impl ScalarCanBeZero {
    pub fn decode_from_slice(v: &[u8]) -> Option<Self> {
        if v.len() != 32 {
            None
        } else {
            let mut tmp = [0u8; 32];
            tmp.copy_from_slice(v);
            curve25519_dalek::scalar::Scalar::from_canonical_bytes(tmp).map(Self)
        }
    }

    pub fn decode(v: [u8; 32]) -> Option<Self> {
        curve25519_dalek::scalar::Scalar::from_canonical_bytes(v).map(Self)
    }

    pub fn one() -> Self {
        Self(curve25519_dalek::scalar::Scalar::one())
    }

    pub fn zero() -> Self {
        Self(curve25519_dalek::scalar::Scalar::zero())
    }

    pub fn is_zero(&self) -> bool {
        self.0.as_bytes().iter().all(|x| *x == 0)
    }
}

impl From<ScalarNonZero> for ScalarCanBeZero {
    fn from(value: ScalarNonZero) -> Self {
        Self(value.0)
    }
}

impl TryFrom<ScalarCanBeZero> for ScalarNonZero {
    type Error = ZeroArgumentError;

    fn try_from(value: ScalarCanBeZero) -> Result<Self, Self::Error> {
        if value.is_zero() {
            Err(ZeroArgumentError)
        } else {
            Ok(Self(value.0))
        }
    }
}

pub trait ScalarTraits {
    fn encode(&self) -> [u8; 32] {
        let mut retval = [0u8; 32];
        retval[0..32].clone_from_slice(self.raw().as_bytes());
        retval
    }
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar;
}

impl ScalarTraits for ScalarCanBeZero {
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar {
        &self.0
    }
}

impl ScalarTraits for ScalarNonZero {
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar {
        &self.0
    }
}

impl<'a, 'b> std::ops::Add<&'b ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 + rhs.0)
    }
}
impl<'b> std::ops::Add<&'b ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(mut self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}
impl<'a> std::ops::Add<ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(self, mut rhs: ScalarCanBeZero) -> Self::Output {
        rhs.0 += self.0;
        rhs
    }
}
impl std::ops::Add<ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(mut self, rhs: ScalarCanBeZero) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Sub<&'b ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 - rhs.0)
    }
}
impl<'b> std::ops::Sub<&'b ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(mut self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}
impl<'a> std::ops::Sub<ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(self, rhs: ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 - rhs.0)
    }
}
impl std::ops::Sub<ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(mut self, rhs: Self) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Mul<&'b ScalarNonZero> for &'a ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(self, rhs: &'b ScalarNonZero) -> Self::Output {
        ScalarNonZero(self.0 * rhs.0)
    }
}
impl<'b> std::ops::Mul<&'b ScalarNonZero> for ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(mut self, rhs: &'b ScalarNonZero) -> Self::Output {
        self.0 *= rhs.0;
        self
    }
}
impl<'a> std::ops::Mul<ScalarNonZero> for &'a ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(self, mut rhs: ScalarNonZero) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl std::ops::Mul<ScalarNonZero> for ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(mut self, rhs: Self) -> Self::Output {
        self.0 *= rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Add<&'b GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn add(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 + rhs.0)
    }
}
impl<'b> std::ops::Add<&'b GroupElement> for GroupElement {
    type Output = GroupElement;

    fn add(mut self, rhs: &'b GroupElement) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}
impl<'a> std::ops::Add<GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn add(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 += self.0;
        rhs
    }
}
impl std::ops::Add<GroupElement> for GroupElement {
    type Output = GroupElement;

    fn add(mut self, rhs: Self) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Sub<&'b GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn sub(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 - rhs.0)
    }
}
impl<'b> std::ops::Sub<&'b GroupElement> for GroupElement {
    type Output = GroupElement;

    fn sub(mut self, rhs: &'b GroupElement) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}
impl<'a> std::ops::Sub<GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn sub(self, rhs: GroupElement) -> Self::Output {
        GroupElement(self.0 - rhs.0)
    }
}
impl std::ops::Sub<GroupElement> for GroupElement {
    type Output = GroupElement;

    fn sub(mut self, rhs: Self) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a,'b> std::ops::Mul<&'b GroupElement> for &'a ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'b> std::ops::Mul<&'b GroupElement> for ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'a> std::ops::Mul<GroupElement> for &'a ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl std::ops::Mul<GroupElement> for ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl<'a,'b> std::ops::Mul<&'b GroupElement> for &'a ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'b> std::ops::Mul<&'b GroupElement> for ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'a> std::ops::Mul<GroupElement> for &'a ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl std::ops::Mul<GroupElement> for ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}

/// ElGamal ciphertext on which the three PEP operations can be performed:
/// - [rerandomize]: change encrypted representation, same contents when decrypted;
/// - [reshuffle]: change encrypted representation, different contents when decrypted;
/// - [rekey]: change encrypted representation, can be decrypted by a different key.
#[derive(Debug,Eq,PartialEq)]
pub struct ElGamal {
  pub b: GroupElement,
  pub c: GroupElement,
  pub y: GroupElement,
}


impl ElGamal {
    pub fn encode(&self) -> [u8; 96] {
        let mut retval = [0u8; 96];
        retval[0..32].clone_from_slice(self.b.0.compress().as_bytes());
        retval[32..64].clone_from_slice(self.c.0.compress().as_bytes());
        retval[64..96].clone_from_slice(self.y.0.compress().as_bytes());
        retval
    }

    pub fn decode(v: &[u8]) -> Option<Self> {
        if v.len() != 96 {
            None
        } else {
            Some(Self {
                b: GroupElement::decode_from_slice(&v[0..32])?,
                c: GroupElement::decode_from_slice(&v[32..64])?,
                y: GroupElement::decode_from_slice(&v[64..96])?,
            })
        }
    }

    pub fn clone(&self) -> Self {
        Self {
            b: self.b,
            c: self.c,
            y: self.y,
        }
    }
}

/// Encrypt message [GroupElement] `msg` using public key [GroupElement] `public_key` to a ElGamal tuple.
pub fn encrypt<R: RngCore + CryptoRng>(msg: &GroupElement, public_key: &GroupElement, rng: &mut R) -> ElGamal {
    let r = ScalarNonZero::random(rng); // random() should never return a zero scalar
    debug_assert!(public_key != &GroupElement::identity()); // we should not encrypt anything with an empty public key, as this will result in plain text send over the line
    ElGamal {
        b: r*G,
        c: msg + r*public_key,
        y: *public_key
    }
}


/// Encrypt message [GroupElement] `msg` using randomized public key [GroupElement] `public_key` and the randomizer [GroupElement] `randomizer_g` to a ElGamal tuple. A randomized public key can be computed from a [GroupElement] public key `pk` by `randomizer*pk` using a random [ScalarNonZero] randomizer. The `randomizer` can be converted to the necessary [GroupElement] argument by doing `randomizer*G`.
pub fn encrypt_using_randomizer<R: RngCore + CryptoRng>(msg: &GroupElement, public_key: &GroupElement, randomizer_g: &GroupElement, rng: &mut R) -> ElGamal {
    debug_assert!(public_key != &GroupElement::identity()); // we should not encrypt anything with an empty public key, as this will result in plain text send over the line
    let r = ScalarNonZero::random(rng); // random() should never return a zero scalar
    ElGamal {
        b: r*G,
        c: msg + r*public_key + r*randomizer_g,
        y: *public_key
    }
}
/// Decrypt ElGamal tuple (encrypted using `secret_key * G`) using secret key [ScalarNonZero] `secret_key`.
pub fn decrypt(s: &ElGamal, secret_key: &ScalarNonZero) -> GroupElement {
    s.c - secret_key*s.b
}

/// Change encrypted representation using [ScalarNonZero] `s`, same contents when decrypted.
pub fn rerandomize(v: &ElGamal, s: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: s*G + v.b,
        c: s*v.y + v.c,
        y: v.y
    }
}

/// Change encrypted representation using [ScalarNonZero] `k`, so it can be decrypted by a different key `k*y` if the input can be decrypted by [ScalarNonZero] `y`.
pub fn rekey(v: &ElGamal, k: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: k.invert() * v.b,
        c: v.c,
        y: k * v.y,
    }
}

/// Change encrypted representation using [ScalarNonZero] `n` so that is has different contents when decrypted equal to `n*msg`, if the original encrypted message was [GroupElement] `msg`. 
pub fn reshuffle(v: &ElGamal, n: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: n * v.b,
        c: n * v.c,
        y: v.y
    }
}

/// Combination of `rekey(k)` and `reshuffle(n)`
pub fn rks(v: &ElGamal, k: &ScalarNonZero, n: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: (n * k.invert()) * v.b,
        c: n * v.c,
        y: k * v.y
    }
}

//////////////////////////

/// Zero-knowledge proofs useful for example if PEP is distributed across multiple hosts.
pub mod zkp {
use crate::*;

// Offline Schnorr proof using Fiat-Shamir transform.
// Proof that given a GroupElement `m` and a scalar `a`,
// member `n` is equal to `a*m`. This can be verified using
// this struct, the original `m` and `a*G`, so that the original
// scalar `a` remains secret.
pub struct Proof {
  pub n: GroupElement,
  pub c1: GroupElement,
  pub c2: GroupElement,
  pub s: ScalarCanBeZero,
}

impl std::ops::Deref for Proof {
    type Target = GroupElement;

    fn deref(&self) -> &Self::Target {
        &self.n
    }
}

// returns <A=a*G, Proof with a value N = a*M>
pub fn create_proof<R: RngCore + CryptoRng>(a: &ScalarNonZero /*secret*/, gm: &GroupElement /*public*/, rng: &mut R) -> (GroupElement,Proof) {
    let r = ScalarNonZero::random(rng);

    let ga = a*G;
    let gn = a*gm;
    let gc1 = r*G;
    let gc2 = r*gm;

    let mut hasher = Sha512::default();
    hasher.update(ga.encode());
    hasher.update(gm.encode());
    hasher.update(gn.0.compress().as_bytes());
    hasher.update(gc1.0.compress().as_bytes());
    hasher.update(gc2.0.compress().as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    let e = ScalarNonZero::from_hash(&bytes);
    let s = ScalarCanBeZero::from(a*e) + ScalarCanBeZero::from(r);
    (ga, Proof {n: gn, c1: gc1, c2: gc2, s})
}

#[must_use]
pub fn verify_proof_split(ga: &GroupElement, gm: &GroupElement, gn: &GroupElement, gc1: &GroupElement, gc2: &GroupElement, s: &ScalarCanBeZero) -> bool {
    let mut hasher = Sha512::default();
    hasher.update(ga.0.compress().as_bytes());
    hasher.update(gm.0.compress().as_bytes());
    hasher.update(gn.0.compress().as_bytes());
    hasher.update(gc1.0.compress().as_bytes());
    hasher.update(gc2.0.compress().as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    let e = ScalarNonZero::from_hash(&bytes);
    // FIXME: speed up with https://docs.rs/curve25519-dalek/latest/curve25519_dalek/traits/trait.VartimeMultiscalarMul.html
    // FIXME: check if a faster non-constant time equality can be used
    s*G == e*ga + gc1 && s*gm == e*gn + gc2
    // (a*e + r)*G = e*a*G + r*G
    // (a*e + r)*gm == e*a*gm + r*gm
}

#[must_use]
pub fn verify_proof(ga: &GroupElement, gm: &GroupElement, p: &Proof) -> bool {
    verify_proof_split(ga, gm, &p.n, &p.c1, &p.c2, &p.s)
}

//// SIGNATURES

type Signature = Proof;

pub fn sign<R: RngCore + CryptoRng>(message: &GroupElement, secret_key: &ScalarNonZero, rng: &mut R) -> Signature {
    create_proof(secret_key, message, rng).1
}

#[must_use]
pub fn verify(message: &GroupElement, p: &Signature, public_key: &GroupElement) -> bool {
    verify_proof(public_key, message, p)
}

//// RERANDOMIZE

// We are re-using some variables from the Proof to reconstruct the Rerandomize operation.
// This way, we only need 1 Proof object (which are fairly large)
type ProvedRerandomize = (GroupElement,Proof);

pub fn prove_rerandomize<R: RngCore + CryptoRng>(v: &ElGamal, s: &ScalarNonZero, rng: &mut R) -> ProvedRerandomize {
    // Rerandomize is normally {s * G + in.b, s*in.y + in.c, in.y};
    create_proof(s, &v.y, rng)
}

#[must_use]
pub fn verify_rerandomize(v: &ElGamal, p: &ProvedRerandomize) -> Option<ElGamal> {
  verify_rerandomize_split(&v.b, &v.c, &v.y, &p.0, &p.1)
}

#[must_use]
pub fn verify_rerandomize_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, s: &GroupElement, p: &Proof) -> Option<ElGamal> {
    // slightly different than the others, as we reuse the structure of a standard proof to reconstruct the Rerandomize operation after sending
    if verify_proof(s, gy, p) {
        Some(ElGamal {
            b: s + gb,
            c: **p + gc,
            y: *gy
        })
    } else {
        None
    }
}

//// RESHUFFLE

/// GroupElement is `n*G` if prove_reshuffle with `n` is called.
pub struct ProvedReshuffle(pub GroupElement, pub Proof, pub Proof);

pub fn prove_reshuffle<R: RngCore + CryptoRng>(v: &ElGamal, n: &ScalarNonZero, rng: &mut R) -> ProvedReshuffle {
    // Reshuffle is normally {n * in.b, n * in.c, in.y};
    // NOTE: can be optimised a bit, by fusing the two CreateProofs (because same n is used, saving a n*G operation)
    let (ab, pb) = create_proof(n, &v.b, rng);
    let (ac, pc) = create_proof(n, &v.c, rng);
    debug_assert_eq!(ab, ac);
    ProvedReshuffle(ab, pb, pc)
}

#[must_use]
pub fn verify_reshuffle(v: &ElGamal, p: &ProvedReshuffle) -> Option<ElGamal> {
  verify_reshuffle_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2)
}

#[must_use]
pub fn verify_reshuffle_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gab: &GroupElement, pb: &Proof, pc: &Proof) -> Option<ElGamal> {
    if verify_proof(gab, gb, pb) && verify_proof(gab, gc, pc) {
        Some(ElGamal {
            b: **pb,
            c: **pc,
            y: *gy,
        })
    } else {
        None
    }
}

impl ProvedReshuffle {
    /// Returns `n*G` after `prove_reshuffle(in, n)`.
    pub fn reshuffled_by(&self) -> GroupElement {
        self.0
    }
}

//// REKEY

/// Second GroupElement is `k*G` if prove_rekey with `k` is called.
pub struct ProvedRekey(pub GroupElement,pub Proof,pub GroupElement,pub Proof);

pub fn prove_rekey<R: RngCore + CryptoRng>(v: &ElGamal, k: &ScalarNonZero, rng: &mut R) -> ProvedRekey {
    // Rekey is normmaly {in.b/k, in.c, k*in.y};
    let (ab, pb) = create_proof(&k.invert(), &v.b, rng);
    let (ay, py) = create_proof(k, &v.y, rng);
    ProvedRekey(ab, pb, ay, py)
}

#[must_use]
pub fn verify_rekey(v: &ElGamal, p: &ProvedRekey) -> Option<ElGamal> {
  verify_rekey_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3)
}

#[must_use]
pub fn verify_rekey_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gab: &GroupElement, pb: &Proof, gay: &GroupElement, py: &Proof) -> Option<ElGamal> {
    if verify_proof(gab, gb, pb) && verify_proof(gay, gy, py) {
        Some(ElGamal {
            b: **pb,
            c: *gc,
            y: **py,
        })
    } else {
        None
    }
}

impl ProvedRekey {
    /// Returns `k*G` after `prove_rekey(in, k)`.
    pub fn rekeyed_by(&self) -> GroupElement {
        self.2
    }
}

//// RKS

/// First GroupElement is `n*G` if prove_rks with `n` is called.
/// Second GroupElement is `k*G` if prove_rks with `k` is called.
pub struct ProvedRKS(pub GroupElement, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof);

pub fn prove_rks<R: RngCore + CryptoRng>(v: &ElGamal, k: &ScalarNonZero, n: &ScalarNonZero, rng: &mut R) -> ProvedRKS {
    // RKS is normally {(n / k) * in.B, n * in.C, k * in.Y};
    let a = create_proof(&(n * k.invert()), &v.b, rng);
    let b = create_proof(n, &v.c, rng);
    let c = create_proof(k, &v.y, rng);
    // different order so that first and second group elements for prove_reshuffle,
    // prove_rekey, prove_rks have the same meaning
    ProvedRKS(b.0, b.1, c.0, c.1, a.0, a.1)
}

#[must_use]
pub fn verify_rks(v: &ElGamal, p: &ProvedRKS) -> Option<ElGamal> {
  verify_rks_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3, &p.4, &p.5)
}

#[must_use]
#[allow(clippy::too_many_arguments)]
pub fn verify_rks_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gac: &GroupElement, pc: &Proof, gay: &GroupElement, py: &Proof, gab: &GroupElement, pb: &Proof) -> Option<ElGamal> {
    if verify_proof(gab, gb, pb) && verify_proof(gac, gc, pc)&& verify_proof(gay, gy, py) {
        Some(ElGamal {
            b: **pb,
            c: **pc,
            y: **py,
        })
    } else {
        None
    }
}

impl ProvedRKS {
    /// Returns `n*G` after `prove_rks(in, k, n)`.
    pub fn reshuffled_by(&self) -> GroupElement {
        self.0
    }
    /// Returns `k*G` after `prove_rks(in, k, n)`.
    pub fn rekeyed_by(&self) -> GroupElement {
        self.2
    }
}
}

/// Higher lever API for simple pseudonimisation on a single host.
pub mod simple {

use crate::*;

type GlobalPublicKey = GroupElement;
type GlobalSecretKey = ScalarNonZero;
type GlobalEncryptedPseudonym = ElGamal;
type LocalEncryptedPseudonym = ElGamal;
type LocalPseudonym = GroupElement;
type LocalDecryptionKey = ScalarNonZero;

pub fn generate_global_keys<R: RngCore + CryptoRng>(rng: &mut R) -> (GlobalPublicKey, GlobalSecretKey) {
    // secret key of system
    let y = ScalarNonZero::random(rng);
    // public key of system
    let gy = y*G;
    (gy, y)
}

/// Generates a non-zero scalar.
fn make_factor(typ: &str, secret: &str, context: &str) -> ScalarNonZero {
    let mut hasher = Sha512::default();
    hasher.update(typ.as_bytes());
    hasher.update(b"|");
    hasher.update(secret.as_bytes());
    hasher.update(b"|");
    hasher.update(context.as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    ScalarNonZero::from_hash(&bytes)
}

/// Generates a non-zero scalar.
pub(crate) fn make_pseudonymisation_factor(secret: &str, context: &str) -> ScalarNonZero {
  make_factor("pseudonym", secret, context)
}

/// Generates a non-zero scalar.
pub fn make_decryption_factor(secret: &str, context: &str) -> ScalarNonZero {
  make_factor("decryption", secret, context)
}

/// Generates a encrypted global pseudonym by encrypting a text with ElGamal using the global
/// public key `pkg`.
pub fn generate_pseudonym<R: RngCore + CryptoRng>(identity: &str, pk: &GlobalPublicKey, rng: &mut R) -> GlobalEncryptedPseudonym {
    let mut hasher = Sha512::default();
    hasher.update(identity.as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    let p = GroupElement::from_hash(&bytes);
    encrypt(&p, pk, rng)
}

/// Using a PEP `rks` operation, convert a global encrypted pseudonym to a local encrypted pseudonym,
/// which is:
/// - decryptable with the key `k` that is generated by [make_local_decryption_key] using the same
///   `decryption_context`;
/// - decrypts to the pseudonym that is the global pseudonym multiplied by a factor specific to the
///   `pseudonimisation_context`.
pub fn convert_to_local_pseudonym(p: &GlobalEncryptedPseudonym, secret: &str, decryption_context: &str, pseudonimisation_context: &str) -> LocalEncryptedPseudonym {
    let u = make_pseudonymisation_factor(secret, pseudonimisation_context);
    let t = make_decryption_factor(secret, decryption_context);
    rks(p, &t, &u)
}

pub fn convert_from_local_pseudonym(p: &LocalEncryptedPseudonym, secret: &str, decryption_context: &str, pseudonimisation_context: &str) -> GlobalEncryptedPseudonym {
    let u = make_pseudonymisation_factor(secret, pseudonimisation_context).invert();
    let t = make_decryption_factor(secret, decryption_context).invert();
    rks(p, &t, &u)
}

pub fn make_local_decryption_key(k: &GlobalSecretKey, secret: &str, decryption_context: &str) -> LocalDecryptionKey {
    let t = make_decryption_factor(secret, decryption_context);
    t*k
}

pub fn decrypt_local_pseudonym(p: &LocalEncryptedPseudonym, k: &LocalDecryptionKey) -> LocalPseudonym {
    decrypt(p, k)
}

pub fn rerandomize_global<R: RngCore + CryptoRng>(p: &GlobalEncryptedPseudonym, rng: &mut R) -> GlobalEncryptedPseudonym {
    rerandomize(p, &ScalarNonZero::random(rng))
}

pub fn rerandomize_local<R: RngCore + CryptoRng>(p: &LocalEncryptedPseudonym, rng: &mut R) -> LocalEncryptedPseudonym {
    rerandomize(p, &ScalarNonZero::random(rng))
}

}

#[cfg(test)]
mod libpep {
    use crate::*;
    use crate::zkp::*;
    use crate::simple::*;
    use rand_core::OsRng;

    #[test]
    fn elgamal_encryption() {
        let mut rng = OsRng;
        // secret key
        let s = ScalarNonZero::random(&mut rng);
        // public key
        let p = s * G;

        // choose a random value to encrypt
        let value = GroupElement::random(&mut rng);

        // encrypt/decrypt this value
        let encrypted = encrypt(&value, &p, &mut OsRng);
        let decrypted = decrypt(&encrypted, &s);

        assert_eq!(value, decrypted);


        let encoded = encrypted.encode();
        let decoded = ElGamal::decode(&encoded);

        assert_eq!(Some(encrypted), decoded);
    }

    #[test]
    fn pep_assumptions() {
        let mut rng = OsRng;
        // secret key of system
        let sk = ScalarNonZero::random(&mut rng);
        // public key of system
        let pk = sk * G;

        // secret key of service provider
        let sj = ScalarNonZero::random(&mut rng);
        let yj = sj * sk;
        assert_eq!(yj * G, sj * pk);

        // Lemma 2: RS(RK(..., k), n) == RK(RS(..., n), k)
        let value = GroupElement::random(&mut rng);
        let encrypted = encrypt(&value, &pk, &mut OsRng);
        let k = ScalarNonZero::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);
        assert_eq!(reshuffle(&rekey(&encrypted, &k), &n), rekey(&reshuffle(&encrypted, &n), &k));
        assert_eq!(reshuffle(&rekey(&encrypted, &k), &n), rks(&encrypted, &k, &n));
    }

    #[test]
    fn elgamal_signature() {
        let mut rng = OsRng;
        // secret key
        let s = ScalarNonZero::random(&mut rng);
        let s2 = ScalarNonZero::random(&mut rng);
        // public key
        let gp = s * G;

        let v = GroupElement::random(&mut rng);
        let mut signature = sign(&v, &s, &mut rng);
        assert!(verify(&v, &signature, &gp));

        signature = sign(&v, &s2, &mut rng);
        assert!(!verify(&v, &signature, &gp));
    }

    #[test]
    fn pep_schnorr_basic_offline() {
        let mut rng = OsRng;
        // given a secret a and public M, proof that a certain triplet (A, M, N) is actually calculated by (a*G, M, a * M)
        // using Fiat-Shamir transform

        // prover
        let a = ScalarNonZero::random(&mut rng);
        let min = GroupElement::random(&mut rng);

        let (ga, p) = create_proof(&a, &min, &mut rng);
        assert_eq!(a * min, *p);

        // verifier
        assert!(verify_proof(&ga, &min, &p));
    }

    #[test]
    fn pep_schnorr_rerandomize() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let s = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rerandomize(&msg, &s, &mut rng);

        let checked = verify_rerandomize(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&rerandomize(&msg, &s), checked.as_ref().unwrap());
    }

    #[test]
    fn pep_schnorr_reshuffle() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_reshuffle(&msg, &n, &mut rng);

        let checked = verify_reshuffle(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(n*gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&reshuffle(&msg, &n), checked.as_ref().unwrap());
    }

    #[test]
    fn pep_schnorr_rekey() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rekey(&msg, &k, &mut rng);
        let checked = verify_rekey(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(proved.rekeyed_by(), k*G);
        assert_eq!(gm, decrypt(checked.as_ref().unwrap(), &(k*y)));
    }

    #[test]
    fn pep_schnorr_rks() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rks(&msg, &k, &n, &mut rng);

        let checked = verify_rks(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(proved.rekeyed_by(), k*G);
        assert_eq!(n*gm, decrypt(checked.as_ref().unwrap(), &(k*y)));
    }

    // https://stackoverflow.com/questions/52987181/how-can-i-convert-a-hex-string-to-a-u8-slice
    use std::{fmt::Write, num::ParseIntError};
    pub fn decode_hex(s: &str) -> Result<Vec<u8>, ParseIntError> {
        (0..s.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&s[i..i + 2], 16))
            .collect()
    }
    #[allow(dead_code)]
    pub fn encode_hex(bytes: &[u8]) -> String {
        let mut s = String::with_capacity(bytes.len() * 2);
        for &b in bytes {
            write!(&mut s, "{:02x}", b).unwrap();
        }
        s
    }

    #[test]
    fn pep_high_level_api() {
        let mut rng = OsRng;
        let (public_key, secret_key) = generate_global_keys(&mut rng);
        //std::cout << "global public key: " << publicKey.hex() << std::endl;
        //std::cout << "global secret key: " << secretKey.hex() << std::endl;

        let id = "foobar";
        let mut gep = generate_pseudonym(id, &public_key, &mut rng);
        //gep = GlobalEncryptedPseudonym::FromHex(gep.hex());
        //std::cout << "global pseudonym for '" << id << "': " << gep.hex() << std::endl;
        gep = rerandomize_global(&gep, &mut rng);
        //std::cout << "global pseudonym for '" << id << "': " << gep.hex() << " (after randomize)" << std::endl;
        //gep = GlobalEncryptedPseudonym::FromHex(gep.hex());
        let mut lep = convert_to_local_pseudonym(&gep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        //lep = LocalEncryptedPseudonym::FromHex(lep.hex());
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << std::endl;
        lep = rerandomize_local(&lep, &mut rng);
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << " (after randomize)" << std::endl;

        let decryption_key = make_local_decryption_key(&secret_key, "very_secret_on_server", "login_session_of_user");
        let lp = decrypt_local_pseudonym(&lep, &decryption_key);
        //let expected = LocalPseudonym::from_hex("4854bb37a8f2e9555f317614290cbef72210901e05f0e0a6623e10df30dfa739");
        let hex = "be26a708fcf722db8d19f6d8c8443794156af30b17c44bcf4bb41791c0708945";
        let expected = decode_hex(hex).unwrap();
        //assert_eq!(lp.hex(), expected.hex());
        assert_eq!(&lp.encode()[..], &expected);
        //std::cout << "(decrypted local pseudonym) for '" << id << "': " << lp.hex() << std::endl;
        
        let gep = convert_from_local_pseudonym(&lep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        let mut lep = convert_to_local_pseudonym(&gep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        //lep = LocalEncryptedPseudonym::FromHex(lep.hex());
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << std::endl;
        lep = rerandomize_local(&lep, &mut rng);
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << " (after randomize)" << std::endl;

        let decryption_key = make_local_decryption_key(&secret_key, "very_secret_on_server", "login_session_of_user");
        let lp = decrypt_local_pseudonym(&lep, &decryption_key);
        //let expected = LocalPseudonym::from_hex("4854bb37a8f2e9555f317614290cbef72210901e05f0e0a6623e10df30dfa739");
        let hex = "be26a708fcf722db8d19f6d8c8443794156af30b17c44bcf4bb41791c0708945";
        let expected = decode_hex(hex).unwrap();
        //assert_eq!(lp.hex(), expected.hex());
        assert_eq!(&lp.encode()[..], &expected);
    }

    #[test]
    fn pep_3_with_zkp() {
        let mut rng = OsRng;

        let (global_public_key, global_secret_key) = generate_global_keys(&mut rng);

        let server1_secret_pseudonymisation_scalar = ScalarNonZero::random(&mut rng);
        let server1_public_pseudonymisation_group_element = server1_secret_pseudonymisation_scalar * G;
        let server1_secret_rekeying_scalar = ScalarNonZero::random(&mut rng);
        let server1_public_rekeying_group_element = server1_secret_rekeying_scalar * G;

        let server2_secret_pseudonymisation_scalar = ScalarNonZero::random(&mut rng);
        let server2_public_pseudonymisation_group_element = server2_secret_pseudonymisation_scalar * G;
        let server2_secret_rekeying_scalar = ScalarNonZero::random(&mut rng);
        let server2_public_rekeying_group_element = server2_secret_rekeying_scalar * G;

        let server3_secret_pseudonymisation_scalar = ScalarNonZero::random(&mut rng);
        let server3_public_pseudonymisation_group_element = server3_secret_pseudonymisation_scalar * G;
        let server3_secret_rekeying_scalar = ScalarNonZero::random(&mut rng);
        let server3_public_rekeying_group_element = server3_secret_rekeying_scalar * G;

        let blinded_global_secret_key = server1_secret_pseudonymisation_scalar * server2_secret_pseudonymisation_scalar * server3_secret_pseudonymisation_scalar * global_secret_key;


        // SESSION INITIALIZATION
        let secret = "verysecret";
        let pseudonymisation_context = "pc-user-a";
        let decryption_context = "dc-user-a";
        let v = make_pseudonymisation_factor(secret, pseudonymisation_context);
        let w = make_decryption_factor(secret, decryption_context);

        let server1_decryption_key_part = w * server1_secret_pseudonymisation_scalar.invert() * server1_secret_rekeying_scalar;
        let server2_decryption_key_part = w * server2_secret_pseudonymisation_scalar.invert() * server2_secret_rekeying_scalar;
        let server3_decryption_key_part = w * server3_secret_pseudonymisation_scalar.invert() * server3_secret_rekeying_scalar;

        // On client A:
        // - Client A has a pseudonym and wants to convert it to a pseudonym for client B, using the PEP network of servers
        let lp_a = GroupElement::random(&mut rng); // local pseudonym
        let pp_a = encrypt(&lp_a, &global_public_key, &mut rng); // polymorphic pseudonym
        // or using an existing persistent/main identifier:
        // let id = "foobar";
        // let mut pp = generate_pseudonym(id, &public_key, &mut rng);

        let plaintext_a = GroupElement::random(&mut rng); // data
        let ciphertext_a = encrypt(&plaintext_a, &global_public_key, &mut rng);

        // On PEP server 1:
        // - Receive polymorphic pseudonym from client and re-key/shuffle it with your own secret scalar
        let pp_before_reshuffle1 = rerandomize(&pp_a, &ScalarNonZero::random(&mut rng));
        let proved_rks1 = prove_rks(&pp_before_reshuffle1, &(w*server1_secret_rekeying_scalar), &(v*server1_secret_pseudonymisation_scalar), &mut rng);
        let _rks1 = rks(&pp_a, &(w*server1_secret_rekeying_scalar), &(v*server1_secret_pseudonymisation_scalar)); // effectively sent
        let proved_data_rekey1 = prove_rekey(&ciphertext_a, &(w*server1_secret_rekeying_scalar), &mut rng);


        // On PEP server 2:
        // - Verify that server 1 has re-key/shuffled the pseudonym correctly
        // - Receive polymorphic pseudonym from server 1 and re-key/shuffle it with your own secret scalar as well
        assert_eq!(proved_rks1.reshuffled_by(), v*server1_public_pseudonymisation_group_element);
        assert_eq!(proved_rks1.rekeyed_by(), w*server1_public_rekeying_group_element);
        assert_eq!(proved_data_rekey1.rekeyed_by(), w*server1_public_rekeying_group_element);
        let pp_received2 = verify_rks(&pp_before_reshuffle1, &proved_rks1).unwrap();
        let pp_before_reshuffle2 = rerandomize(&pp_received2, &ScalarNonZero::random(&mut rng));
        let ciphertext_received2 = verify_rekey(&ciphertext_a, &proved_data_rekey1).unwrap();

        let proved_rks2 = prove_rks(&pp_before_reshuffle2, &(w*server2_secret_rekeying_scalar), &(v*server2_secret_pseudonymisation_scalar), &mut rng);
        let _rks2 = rks(&pp_a, &(w*server2_secret_rekeying_scalar), &(v*server2_secret_pseudonymisation_scalar)); // effectively sent
        let proved_data_rekey2 = prove_rekey(&ciphertext_received2, &(w*server2_secret_rekeying_scalar), &mut rng);


        // On PEP server 3:
        // - Verify that server 1 and server 2 have re-key/shuffled the pseudonym correctly
        // - Receive polymorphic pseudonym from server 2 and re-key/shuffle it with your own secret scalar as well
        assert_eq!(proved_rks1.reshuffled_by(), v*server1_public_pseudonymisation_group_element);
        assert_eq!(proved_rks1.rekeyed_by(), w*server1_public_rekeying_group_element);
        assert_eq!(proved_data_rekey1.rekeyed_by(), w*server1_public_rekeying_group_element);
        assert_eq!(proved_rks2.reshuffled_by(), v*server2_public_pseudonymisation_group_element);
        assert_eq!(proved_rks2.rekeyed_by(), w*server2_public_rekeying_group_element);
        assert_eq!(proved_data_rekey2.rekeyed_by(), w*server2_public_rekeying_group_element);
        let pp_received3 = verify_rks(&pp_before_reshuffle2, &proved_rks2).unwrap();
        let pp_before_reshuffle3 = rerandomize(&pp_received3, &ScalarNonZero::random(&mut rng));
        let ciphertext_received3 = verify_rekey(&ciphertext_received2, &proved_data_rekey2).unwrap();

        let proved_rks3 = prove_rks(&pp_before_reshuffle3, &(w*server3_secret_rekeying_scalar), &(v*server3_secret_pseudonymisation_scalar), &mut rng);
        let _rks3 = rks(&pp_a, &(w*server3_secret_rekeying_scalar), &(v*server3_secret_pseudonymisation_scalar)); // effectively sent
        let proved_data_rekey3 = prove_rekey(&ciphertext_received3, &(w*server3_secret_rekeying_scalar), &mut rng);


        // On PEP server 1:
        // - Verify that server 2 has re-key/shuffled the pseudonym correctly
        // - Send it back to the client
        // NB 1: we could also send the proof of the second reshuffle back to client A (and let the client verify the reshuffle of both servers).
        //     However, if we consider server 1 to be a primary entry point for party A that should handle all crypto on behalf of party A, then this design is preferred.
        // NB 2: to prevent binary comparison of the two reshuffled pseudonyms, we rerandomize it once more
        // TODO what is actually the attack here
        assert_eq!(proved_rks2.reshuffled_by(), v*server2_public_pseudonymisation_group_element);
        assert_eq!(proved_rks2.rekeyed_by(), w*server2_public_rekeying_group_element);
        assert_eq!(proved_data_rekey2.rekeyed_by(), w*server2_public_rekeying_group_element);
        assert_eq!(proved_rks3.reshuffled_by(), v*server3_public_pseudonymisation_group_element);
        assert_eq!(proved_rks3.rekeyed_by(), w*server3_public_rekeying_group_element);
        assert_eq!(proved_data_rekey3.rekeyed_by(), w*server3_public_rekeying_group_element);
        let pp_received = verify_rks(&pp_before_reshuffle3, &proved_rks3).unwrap();
        let pp_b = rerandomize(&pp_received, &ScalarNonZero::random(&mut rng)); // TODO proved_rerandomize should probably be used here, but why again?
        let ciphertext_b = verify_rekey(&ciphertext_received3, &proved_data_rekey3).unwrap();


        // On client B:
        // - Receive the polymorphic pseudonym from client A
        // - Receive the decryption factors from all servers (after authentication)
        // - Receive and verify the re-key/shuffle proofs from all servers
        // - Decrypt pp_b using the secret key that you can calculate from the decryption factors
        assert_eq!(proved_rks1.reshuffled_by(), v*server1_public_pseudonymisation_group_element);
        assert_eq!(proved_rks1.rekeyed_by(), w*server1_public_rekeying_group_element);
        assert_eq!(proved_data_rekey1.rekeyed_by(), w*server1_public_rekeying_group_element);
        assert_eq!(proved_rks2.reshuffled_by(), v*server2_public_pseudonymisation_group_element);
        assert_eq!(proved_rks2.rekeyed_by(), w*server2_public_rekeying_group_element);
        assert_eq!(proved_data_rekey2.rekeyed_by(), w*server2_public_rekeying_group_element);
        assert_eq!(proved_rks3.reshuffled_by(), v*server3_public_pseudonymisation_group_element);
        assert_eq!(proved_rks3.rekeyed_by(), w*server3_public_rekeying_group_element);
        assert_eq!(proved_data_rekey3.rekeyed_by(), w*server3_public_rekeying_group_element);
        let decryption_key_b = server1_decryption_key_part * server2_decryption_key_part * server3_decryption_key_part * blinded_global_secret_key;
        let lp_b = decrypt(&pp_b, &decryption_key_b);
        let plaintext_b = decrypt(&ciphertext_b, &decryption_key_b);
        // lp_b is the local pseudonym of lp_a for client B


        // TESTING FRAMEWORK
        let expected_lp_b = decrypt(&rks(&rks(&rks(&pp_a, &(w*server1_secret_rekeying_scalar), &(v*server1_secret_pseudonymisation_scalar)), &(w*server2_secret_rekeying_scalar), &(v*server2_secret_pseudonymisation_scalar)), &(w*server3_secret_rekeying_scalar), &(v*server3_secret_pseudonymisation_scalar)),&decryption_key_b);
        assert_eq!(expected_lp_b, lp_b);
        assert_eq!(plaintext_a, plaintext_b);
    }


    #[test]
    fn n_pep_rks_with_zkp() {
        let n = 5;
        let mut rng = OsRng;

        // SERVER DEFINITION
        pub struct Server {
            pseudonymisation_scalar: ScalarNonZero,
            pseudonymisation_group_element: GroupElement,
            rekeying_scalar: ScalarNonZero,
            rekeying_group_element: GroupElement,
            session: Option<ServerSession>,
        }
        pub struct ServerSession {
            v: ScalarNonZero,
            w: ScalarNonZero,
            decryption_key_part: ScalarNonZero,
        }
        impl Server {
            fn new(rng: &mut OsRng) -> Server {
                let pseudonymisation_scalar = ScalarNonZero::random(rng);
                let pseudonymisation_group_element = pseudonymisation_scalar * G;
                let rekeying_scalar = ScalarNonZero::random(rng);
                let rekeying_group_element = rekeying_scalar * G;
                Server {
                    pseudonymisation_scalar,
                    pseudonymisation_group_element,
                    rekeying_scalar,
                    rekeying_group_element,
                    session: None,
                }
            }
            fn new_session(&mut self, secret: &str, pseudonymisation_context: &str, decryption_context: &str) {
                self.session = Some(ServerSession::new(self, secret, pseudonymisation_context, decryption_context));
            }
        }
        impl ServerSession {
            fn new(server: &Server, secret: &str, pseudonymisation_context: &str, decryption_context: &str ) -> ServerSession {
                let v = make_pseudonymisation_factor(secret, pseudonymisation_context);
                let w = make_decryption_factor(secret, decryption_context);
                let decryption_key_part = w * server.pseudonymisation_scalar.invert() * server.rekeying_scalar;
                ServerSession {
                    v,
                    w,
                    decryption_key_part,
                }
            }
        }

        let mut servers = Vec::new();

        // Messages over the network:
        let mut received_pps:Vec<ElGamal> = Vec::new();
        let mut received_ciphertexts:Vec<ElGamal> = Vec::new();
        let mut proved_rkss:Vec<ProvedRKS> = Vec::new();
        let mut proved_data_rekeys:Vec<ProvedRekey> = Vec::new();

        fn verify_zkps(n: usize, servers: &Vec<Server>, received_pps: &Vec<ElGamal>, proved_rkss: &Vec<ProvedRKS>, received_ciphertexts: &Vec<ElGamal>, proved_data_rekeys: &Vec<ProvedRekey>) {
            for i in 0..n {
                let server = &servers[i];
                assert_eq!(proved_rkss[i].reshuffled_by(), server.session.as_ref().unwrap().v*server.pseudonymisation_group_element);
                assert_eq!(proved_rkss[i].rekeyed_by(), server.session.as_ref().unwrap().w*server.rekeying_group_element);
                assert_eq!(proved_data_rekeys[i].rekeyed_by(), server.session.as_ref().unwrap().w*server.rekeying_group_element);
            }
        }


        // SYSTEM INITIALIZATION
        let (global_public_key, global_secret_key) = generate_global_keys(&mut rng);
        for _ in 0..n {
            servers.push(Server::new(&mut rng));
        }
        let blinded_global_secret_key = servers.iter().fold(global_secret_key, |acc, s| acc * s.pseudonymisation_scalar);


        // SESSION INITIALIZATION
        let secret = "verysecret";
        let pseudonymisation_context = "pc-user-a";
        let decryption_context = "dc-user-a";
        for server in &mut servers {
            server.new_session(secret, pseudonymisation_context, decryption_context);
        }


        // On client A:
        // - Client A has a pseudonym and wants to convert it to a pseudonym for client B, using the PEP network of servers
        let lp_a = GroupElement::random(&mut rng); // local pseudonym
        let pp_a = encrypt(&lp_a, &global_public_key, &mut rng); // polymorphic pseudonym
        // or using an existing persistent/main identifier:
        // let id = "foobar";
        // let mut pp = generate_pseudonym(id, &public_key, &mut rng);

        let plaintext_a = GroupElement::random(&mut rng); // data
        let ciphertext_a = encrypt(&plaintext_a, &global_public_key, &mut rng);

        // On PEP server i (i=0..n):
        for i in 0..n {
            let server = &servers[i];

            // - Verify the re-key/shuffles of all previous servers
            verify_zkps(i, &servers, &received_pps, &proved_rkss, &received_ciphertexts, &proved_data_rekeys);

            // - Receive polymorphic pseudonym from previous server...
            let pp_received = if i == 0 {
                pp_a.clone() // first server receives the pp_a from the uploader
            } else {
                verify_rks(&received_pps.last().unwrap(), &proved_rkss.last().unwrap()).unwrap() // other servers use the pp from the previous server
            };
            let ciphertext_received = if i == 0 {
                ciphertext_a.clone() // first server receives the pp_a from the uploader
            } else {
                verify_rekey(&received_ciphertexts.last().unwrap(), &proved_data_rekeys.last().unwrap()).unwrap() // other servers use the pp from the previous server
            };


            // ... and re-key/shuffle it with your own secret scalar as well
            let pp_before_reshuffle = rerandomize(&pp_received, &ScalarNonZero::random(&mut rng)); // rerandomize the pp before reshuffling
            let proved_rks = prove_rks(&pp_before_reshuffle, &(server.session.as_ref().unwrap().w*server.rekeying_scalar), &(server.session.as_ref().unwrap().v*server.pseudonymisation_scalar), &mut rng);
            let _rks = rks(&pp_received, &(server.session.as_ref().unwrap().w*server.rekeying_scalar), &(server.session.as_ref().unwrap().v*server.pseudonymisation_scalar)); // effectively sent
            let proved_data_rekey = prove_rekey(&ciphertext_received, &(server.session.as_ref().unwrap().w*server.rekeying_scalar), &mut rng);

            // - Send them to the other servers
            received_pps.push(pp_before_reshuffle);
            proved_rkss.push(proved_rks);
            received_ciphertexts.push(ciphertext_received);
            proved_data_rekeys.push(proved_data_rekey);
        }

        // On PEP server 1:
        // The first server is the entry point for the client, so it sends the final pseudonym back to the client
        verify_zkps(n, &servers, &received_pps, &proved_rkss, &received_ciphertexts, &proved_data_rekeys);
        let pp_received = verify_rks(&received_pps.last().unwrap(), &proved_rkss.last().unwrap()).unwrap();
        let pp_b = rerandomize(&pp_received, &ScalarNonZero::random(&mut rng)); // TODO proved_rerandomize should probably be used
        // TODO why do we actually need to rerandomize here?
        let ciphertext_b = verify_rekey(&received_ciphertexts.last().unwrap(), &proved_data_rekeys.last().unwrap()).unwrap();


        // On client B:
        // - Receive the polymorphic pseudonym from client A
        // - Receive the decryption factors from both servers (after authentication)
        // - Receive and verify the re-key/shuffle proofs from all servers
        // - Decrypt pp_b using the secret key that you can calculate from the decryption factors
        verify_zkps(n, &servers, &received_pps, &proved_rkss, &received_ciphertexts, &proved_data_rekeys);
        let decryption_key_b = servers.iter().fold(blinded_global_secret_key, |acc, s| acc * s.session.as_ref().unwrap().decryption_key_part);
        let lp_b = decrypt(&pp_b, &decryption_key_b);
        let plaintext_b = decrypt(&ciphertext_b, &decryption_key_b);


        // TESTING FRAMEWORK
        let expected_lp = decrypt(&servers.iter().fold(pp_a, |acc, s| rks(&acc, &(s.session.as_ref().unwrap().w*s.rekeying_scalar), &(s.session.as_ref().unwrap().v*s.pseudonymisation_scalar))), &decryption_key_b);
        assert_eq!(expected_lp, lp_b);
        assert_eq!(plaintext_a, plaintext_b);
    }
}
