//! This library implements the PEP encryption based on ElGamal, and operations on these encrypted messages. A message [GroupElement] `M` can be encrypted for a receiver which has public key [GroupElement] `Y` associated with it, belonging to secret key [ScalarNonZero] `y`. This encryption is random: a different random [ScalarNonZero] `r` can be used during encryption for a specific public key, resulting in different ciphertexts (encrypted messages) but decryptable by only knowing the secret key. We represent this encryption function as `EG(r, M, Y)`, which is implemented in Rust as [encrypt]. Encrypted messages `msg` are often pseudonyms or AES keys (see below).
//!
//! [ElGamal] ciphertext on which the three PEP operations can be performed:
//! - [rerandomize] by [ScalarNonZero] `s`: change encrypted representation, same contents when decrypted;
//! - [reshuffle] by [ScalarNonZero] `n`: change encrypted representation so that is has different contents when decrypted equal to `n*msg`, if the original encrypted message was [GroupElement] `msg`.
//! - [rekey] by [ScalarNonZero] `k`: change encrypted representation, so it can be decrypted by a different key `k*y` if the input can be decrypted by [ScalarNonZero] `y`.
//!
//! There are also zero knowledge proof version of these operations in module [zkp]. These are needed so that a party can prove to another party that it has applied the operation on the input data, without revealing the factors used in the operation.
//!
//! When distributing trust over multiple central servers, these zero knowledge proofs are essential, so that a malfunctioning server can not violate security guarantees of the system. For example, if reshuffling by `n` a pseudonym on a server, the requestor wants to make sure that the sent over pseudonym is actually reshuffled using the correct factor `n`, instead of a random other pseudonym or a different factor.
//!
//! Same library in different languages:
//! - [libpep-cpp](https://github.com/bvgastel/libpep-cpp) (C++);
//! - [libpep on crates.io](https://crates.io/crates/libpep) (Rust).
//!
//! ## Applications
//!
//! For **pseudonimisation**, the core operation is [reshuffle] with `n`. It modifies a main pseudonym with a factor `n` that is specific to a user (or user group) receiving the pseudonym. After applying a user specific factor `n`, a pseudonym is called a *local pseudonym*. The factor `n` is typically tied to the *access group of a user*.
//! 
//! Using only a reshuffle is insufficient, as the pseudonym is still encrypted with the public key `Y` (which can be decrypted by the secret key `y`). To allow a user to decrypt the encrypted pseudonym, a [rekey] with `k` is needed, in combination with a protocol to hand the user the secret key `k*y`. The factor `k` is typically tied to the *current session of a user*.
//!
//! To make pseudonyms harder to trace, [rerandomize] is applied frequently. This way a binary compare of the encrypted pseudonym will not leak any information.
//!
//! For **data protection**, the [rekey] operation described above allows a [GroupElement] `msg` to be
//! decryptable with another key but decryption results in the same original GroupElement `msg`. This GroupElement
//! can be used as an AES key to encrypt a larger message. Care must be taken that such an AES key is
//! not functioning as a defacto global identifier.
//!
//! ## Implementation
//!
//! This library is using the Ristretto encoding on Curve25519, implemented in the curve25519-dalek crate. There are a number of arithmetic rules for scalars and group elements: group elements can be added and subtracted from each other. Scalars support addition, subtraction, and multiplication. Division can be done by multipling with the inverse (using `s.invert()` for non-zero scalar `s`). A scalar can be converted to a group element (by multiplying with the special generator `G`), but not the other way around. Group elements can also be multiplied by a scalar.
//! 
//! Group elements have an *almost* 32 byte range (top bit is always zero, and some other values are invalid). Therefore, not all AES-256 keys (using the full 32 bytes range) are valid group elements. But all group elements are valid AES-256 keys. Group elements can be generated by [GroupElement::random] or [GroupElement::from_hash]. Scalars are also 32 bytes, and can be generated with [ScalarNonZero::random] or [ScalarNonZero::from_hash].
//!
//! The zero knowledge proofs are offline Schnorr proofs, based on a Fiat-Shamir transform. The hashing algorithm used is SHA512.
use curve25519_dalek::ristretto::RistrettoPoint;
use curve25519_dalek::ristretto::CompressedRistretto;
use curve25519_dalek::traits::Identity;
extern crate rand_core;
extern crate sha2;
use rand::CryptoRng;
use rand::RngCore;
use sha2::{Sha512, Digest};
use crate::zkp::{create_proof, create_proof_inv, Proof, ProofInv, verify_proof, verify_proof_inv};

/// Constant so that a [ScalarNonZero]/[ScalarCanBeZero] s can be converted to a [GroupElement] by performing `s * G`.
const G: GroupElement = GroupElement(curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT);

/// Returned if a zero scalar is inverted (which is similar to why a division by zero is not
/// possible).
#[derive(Debug)]
pub struct ZeroArgumentError;

/// Element on a group. Can not be converted to a scalar. Supports addition and substraction. Multiplication by a scalar is supported.
#[derive(Copy,Clone,Eq,PartialEq,Debug)]
pub struct GroupElement(RistrettoPoint);

impl GroupElement {
    pub fn encode(&self) -> [u8; 32] {
        self.0.compress().0
    }

    pub fn decode_from_slice(v: &[u8]) -> Option<Self> {
        if v.len() != 32 {
            None
        } else {
            CompressedRistretto::from_slice(v).decompress().map(Self)
        }
    }

    pub fn decode(v: [u8; 32]) -> Option<Self> {
        CompressedRistretto(v).decompress().map(Self)
    }
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        Self(RistrettoPoint::random(rng))
    }
    pub fn from_hash(v: &[u8; 64]) -> Self {
        Self(RistrettoPoint::from_uniform_bytes(v))
    }

    pub fn identity() -> Self {
        Self(RistrettoPoint::identity())
    }
}

/// Scalar, always non-zero. Can be converted to a GroupElement. Supports multiplication, and inversion (so division is possible). For addition and substraction, use [ScalarCanBeZero].
#[derive(Copy,Clone,Eq,PartialEq,Debug)]
pub struct ScalarNonZero(curve25519_dalek::scalar::Scalar);

impl ScalarNonZero {
    /// Always return a non-zero scalar.
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        loop {
            let retval = curve25519_dalek::scalar::Scalar::random(rng);
            if !retval.as_bytes().iter().all(|x| *x == 0) {
                return Self(retval);
            }
        }
    }

    pub fn from_hash(v: &[u8; 64]) -> Self {
        let retval = curve25519_dalek::scalar::Scalar::from_bytes_mod_order_wide(v);
        if retval.as_bytes().iter().all(|x| *x == 0) {
            Self(curve25519_dalek::scalar::Scalar::one())
        } else {
            Self(retval)
        }
    }

    pub fn one() -> Self {
        Self(curve25519_dalek::scalar::Scalar::one())
    }

    pub fn invert(&self) -> Self {
        Self(self.0.invert())
    }
}

/// Scalar, can be zero. Can be converted to a GroupElement. Supports multiplication, inversion (so division is possible), addition and substraction.
#[derive(Copy,Clone,Eq,PartialEq,Debug)]
pub struct ScalarCanBeZero(curve25519_dalek::scalar::Scalar);

impl ScalarCanBeZero {
    pub fn decode_from_slice(v: &[u8]) -> Option<Self> {
        if v.len() != 32 {
            None
        } else {
            let mut tmp = [0u8; 32];
            tmp.copy_from_slice(v);
            curve25519_dalek::scalar::Scalar::from_canonical_bytes(tmp).map(Self)
        }
    }

    pub fn decode(v: [u8; 32]) -> Option<Self> {
        curve25519_dalek::scalar::Scalar::from_canonical_bytes(v).map(Self)
    }

    pub fn one() -> Self {
        Self(curve25519_dalek::scalar::Scalar::one())
    }

    pub fn zero() -> Self {
        Self(curve25519_dalek::scalar::Scalar::zero())
    }

    pub fn is_zero(&self) -> bool {
        self.0.as_bytes().iter().all(|x| *x == 0)
    }
}

impl From<ScalarNonZero> for ScalarCanBeZero {
    fn from(value: ScalarNonZero) -> Self {
        Self(value.0)
    }
}

impl TryFrom<ScalarCanBeZero> for ScalarNonZero {
    type Error = ZeroArgumentError;

    fn try_from(value: ScalarCanBeZero) -> Result<Self, Self::Error> {
        if value.is_zero() {
            Err(ZeroArgumentError)
        } else {
            Ok(Self(value.0))
        }
    }
}

pub trait ScalarTraits {
    fn encode(&self) -> [u8; 32] {
        let mut retval = [0u8; 32];
        retval[0..32].clone_from_slice(self.raw().as_bytes());
        retval
    }
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar;
}

impl ScalarTraits for ScalarCanBeZero {
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar {
        &self.0
    }
}

impl ScalarTraits for ScalarNonZero {
    fn raw(&self) -> &curve25519_dalek::scalar::Scalar {
        &self.0
    }
}

impl<'a, 'b> std::ops::Add<&'b ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 + rhs.0)
    }
}
impl<'b> std::ops::Add<&'b ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(mut self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}
impl<'a> std::ops::Add<ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(self, mut rhs: ScalarCanBeZero) -> Self::Output {
        rhs.0 += self.0;
        rhs
    }
}
impl std::ops::Add<ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn add(mut self, rhs: ScalarCanBeZero) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Sub<&'b ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 - rhs.0)
    }
}
impl<'b> std::ops::Sub<&'b ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(mut self, rhs: &'b ScalarCanBeZero) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}
impl<'a> std::ops::Sub<ScalarCanBeZero> for &'a ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(self, rhs: ScalarCanBeZero) -> Self::Output {
        ScalarCanBeZero(self.0 - rhs.0)
    }
}
impl std::ops::Sub<ScalarCanBeZero> for ScalarCanBeZero {
    type Output = ScalarCanBeZero;

    fn sub(mut self, rhs: Self) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Mul<&'b ScalarNonZero> for &'a ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(self, rhs: &'b ScalarNonZero) -> Self::Output {
        ScalarNonZero(self.0 * rhs.0)
    }
}
impl<'b> std::ops::Mul<&'b ScalarNonZero> for ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(mut self, rhs: &'b ScalarNonZero) -> Self::Output {
        self.0 *= rhs.0;
        self
    }
}
impl<'a> std::ops::Mul<ScalarNonZero> for &'a ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(self, mut rhs: ScalarNonZero) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl std::ops::Mul<ScalarNonZero> for ScalarNonZero {
    type Output = ScalarNonZero;

    fn mul(mut self, rhs: Self) -> Self::Output {
        self.0 *= rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Add<&'b GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn add(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 + rhs.0)
    }
}
impl<'b> std::ops::Add<&'b GroupElement> for GroupElement {
    type Output = GroupElement;

    fn add(mut self, rhs: &'b GroupElement) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}
impl<'a> std::ops::Add<GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn add(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 += self.0;
        rhs
    }
}
impl std::ops::Add<GroupElement> for GroupElement {
    type Output = GroupElement;

    fn add(mut self, rhs: Self) -> Self::Output {
        self.0 += rhs.0;
        self
    }
}

impl<'a, 'b> std::ops::Sub<&'b GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn sub(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 - rhs.0)
    }
}
impl<'b> std::ops::Sub<&'b GroupElement> for GroupElement {
    type Output = GroupElement;

    fn sub(mut self, rhs: &'b GroupElement) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}
impl<'a> std::ops::Sub<GroupElement> for &'a GroupElement {
    type Output = GroupElement;

    fn sub(self, rhs: GroupElement) -> Self::Output {
        GroupElement(self.0 - rhs.0)
    }
}
impl std::ops::Sub<GroupElement> for GroupElement {
    type Output = GroupElement;

    fn sub(mut self, rhs: Self) -> Self::Output {
        self.0 -= rhs.0;
        self
    }
}

impl<'a,'b> std::ops::Mul<&'b GroupElement> for &'a ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'b> std::ops::Mul<&'b GroupElement> for ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'a> std::ops::Mul<GroupElement> for &'a ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl std::ops::Mul<GroupElement> for ScalarNonZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl<'a,'b> std::ops::Mul<&'b GroupElement> for &'a ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'b> std::ops::Mul<&'b GroupElement> for ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, rhs: &'b GroupElement) -> Self::Output {
        GroupElement(self.0 * rhs.0)
    }
}
impl<'a> std::ops::Mul<GroupElement> for &'a ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}
impl std::ops::Mul<GroupElement> for ScalarCanBeZero {
    type Output = GroupElement;

    fn mul(self, mut rhs: GroupElement) -> Self::Output {
        rhs.0 *= self.0;
        rhs
    }
}

/// ElGamal ciphertext on which the three PEP operations can be performed:
/// - [rerandomize]: change encrypted representation, same contents when decrypted;
/// - [reshuffle]: change encrypted representation, different contents when decrypted;
/// - [rekey]: change encrypted representation, can be decrypted by a different key.
#[derive(Debug,Eq,PartialEq)]
pub struct ElGamal {
  pub b: GroupElement,
  pub c: GroupElement,
  pub y: GroupElement,
}


impl ElGamal {
    pub fn encode(&self) -> [u8; 96] {
        let mut retval = [0u8; 96];
        retval[0..32].clone_from_slice(self.b.0.compress().as_bytes());
        retval[32..64].clone_from_slice(self.c.0.compress().as_bytes());
        retval[64..96].clone_from_slice(self.y.0.compress().as_bytes());
        retval
    }

    pub fn decode(v: &[u8]) -> Option<Self> {
        if v.len() != 96 {
            None
        } else {
            Some(Self {
                b: GroupElement::decode_from_slice(&v[0..32])?,
                c: GroupElement::decode_from_slice(&v[32..64])?,
                y: GroupElement::decode_from_slice(&v[64..96])?,
            })
        }
    }

    pub fn clone(&self) -> Self {
        Self {
            b: self.b,
            c: self.c,
            y: self.y,
        }
    }
}

/// Encrypt message [GroupElement] `msg` using public key [GroupElement] `public_key` to a ElGamal tuple.
pub fn encrypt<R: RngCore + CryptoRng>(msg: &GroupElement, public_key: &GroupElement, rng: &mut R) -> ElGamal {
    let r = ScalarNonZero::random(rng); // random() should never return a zero scalar
    debug_assert!(public_key != &GroupElement::identity()); // we should not encrypt anything with an empty public key, as this will result in plain text send over the line
    ElGamal {
        b: r*G,
        c: msg + r*public_key,
        y: *public_key
    }
}


/// Encrypt message [GroupElement] `msg` using randomized public key [GroupElement] `public_key` and the randomizer [GroupElement] `randomizer_g` to a ElGamal tuple. A randomized public key can be computed from a [GroupElement] public key `pk` by `randomizer*pk` using a random [ScalarNonZero] randomizer. The `randomizer` can be converted to the necessary [GroupElement] argument by doing `randomizer*G`.
pub fn encrypt_using_randomizer<R: RngCore + CryptoRng>(msg: &GroupElement, public_key: &GroupElement, randomizer_g: &GroupElement, rng: &mut R) -> ElGamal {
    debug_assert!(public_key != &GroupElement::identity()); // we should not encrypt anything with an empty public key, as this will result in plain text send over the line
    let r = ScalarNonZero::random(rng); // random() should never return a zero scalar
    ElGamal {
        b: r*G,
        c: msg + r*public_key + r*randomizer_g,
        y: *public_key
    }
}
/// Decrypt ElGamal tuple (encrypted using `secret_key * G`) using secret key [ScalarNonZero] `secret_key`.
pub fn decrypt(s: &ElGamal, secret_key: &ScalarNonZero) -> GroupElement {
    s.c - secret_key*s.b
}

/// Change encrypted representation using [ScalarNonZero] `s`, same contents when decrypted.
pub fn rerandomize(v: &ElGamal, s: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: s*G + v.b,
        c: s*v.y + v.c,
        y: v.y
    }
}

/// Change encrypted representation using [ScalarNonZero] `k`, so it can be decrypted by a different key `k*y` if the input can be decrypted by [ScalarNonZero] `y`.
pub fn rekey(v: &ElGamal, k: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: k.invert() * v.b,
        c: v.c,
        y: k * v.y,
    }
}

/// Change encrypted representation using [ScalarNonZero] `n` so that is has different contents when decrypted equal to `n*msg`, if the original encrypted message was [GroupElement] `msg`. 
pub fn reshuffle(v: &ElGamal, n: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: n * v.b,
        c: n * v.c,
        y: v.y
    }
}

/// Combination of `rekey(k)` and `reshuffle(n)`
pub fn rks(v: &ElGamal, k: &ScalarNonZero, n: &ScalarNonZero) -> ElGamal {
    ElGamal {
        b: (n * k.invert()) * v.b,
        c: n * v.c,
        y: k * v.y
    }
}

//////////////////////////

/// Zero-knowledge proofs useful for example if PEP is distributed across multiple hosts.
pub mod zkp {
    use crate::*;

    // Offline Schnorr proof using Fiat-Shamir transform.
// Proof that given a GroupElement `m` and a scalar `a`,
// member `n` is equal to `a*m`. This can be verified using
// this struct, the original `m` and `a*G`, so that the original
// scalar `a` remains secret.
    pub struct Proof {
        pub n: GroupElement,
        pub c1: GroupElement,
        pub c2: GroupElement,
        pub s: ScalarCanBeZero,
    }

    impl std::ops::Deref for Proof {
        type Target = GroupElement;

        fn deref(&self) -> &Self::Target {
            &self.n
        }
    }

    // returns <A=a*G, Proof with a value N = a*M>
    pub fn create_proof<R: RngCore + CryptoRng>(a: &ScalarNonZero /*secret*/, gm: &GroupElement /*public*/, rng: &mut R) -> (GroupElement, Proof) {
        let r = ScalarNonZero::random(rng);

        let ga = a * G;
        let gn = a * gm;
        let gc1 = r * G;
        let gc2 = r * gm;

        let mut hasher = Sha512::default();
        hasher.update(ga.encode());
        hasher.update(gm.encode());
        hasher.update(gn.0.compress().as_bytes());
        hasher.update(gc1.0.compress().as_bytes());
        hasher.update(gc2.0.compress().as_bytes());
        let mut bytes = [0u8; 64];
        bytes.copy_from_slice(hasher.finalize().as_slice());
        let e = ScalarNonZero::from_hash(&bytes);
        let s = ScalarCanBeZero::from(a * e) + ScalarCanBeZero::from(r);
        (ga, Proof { n: gn, c1: gc1, c2: gc2, s })
    }

    #[must_use]
    pub fn verify_proof_split(ga: &GroupElement, gm: &GroupElement, gn: &GroupElement, gc1: &GroupElement, gc2: &GroupElement, s: &ScalarCanBeZero) -> bool {
        let mut hasher = Sha512::default();
        hasher.update(ga.0.compress().as_bytes());
        hasher.update(gm.0.compress().as_bytes());
        hasher.update(gn.0.compress().as_bytes());
        hasher.update(gc1.0.compress().as_bytes());
        hasher.update(gc2.0.compress().as_bytes());
        let mut bytes = [0u8; 64];
        bytes.copy_from_slice(hasher.finalize().as_slice());
        let e = ScalarNonZero::from_hash(&bytes);
        // FIXME: speed up with https://docs.rs/curve25519-dalek/latest/curve25519_dalek/traits/trait.VartimeMultiscalarMul.html
        // FIXME: check if a faster non-constant time equality can be used
        s * G == e * ga + gc1 && s * gm == e * gn + gc2
        // (a*e + r)*G = e*a*G + r*G
        // (a*e + r)*gm == e*a*gm + r*gm
    }

    #[must_use]
    pub fn verify_proof(ga: &GroupElement, gm: &GroupElement, p: &Proof) -> bool {
        verify_proof_split(ga, gm, &p.n, &p.c1, &p.c2, &p.s)
    }


    pub struct ProofInv {
        pub ga_inv: GroupElement,
        pub gc: GroupElement,
        pub s: ScalarCanBeZero,
    }

    impl std::ops::Deref for ProofInv {
        type Target = GroupElement;

        fn deref(&self) -> &Self::Target {
            &self.ga_inv
        }
    }

    // returns <A=a*G, Proof with a value N = a^-1*G>
    pub fn create_proof_inv<R: RngCore + CryptoRng>(a: &ScalarNonZero /*secret*/, rng: &mut R) -> (GroupElement, ProofInv) {
        let r = ScalarNonZero::random(rng);

        let ga = a * G;
        let ga_inv = a.invert() * G;
        let gc = r * G;

        let mut hasher = Sha512::default();
        hasher.update(ga.0.compress().as_bytes());
        hasher.update(ga_inv.0.compress().as_bytes());
        hasher.update(gc.0.compress().as_bytes());
        let mut bytes = [0u8; 64];
        bytes.copy_from_slice(hasher.finalize().as_slice());
        let e = ScalarNonZero::from_hash(&bytes);
        let s = ScalarCanBeZero::from(a.invert() * e) + ScalarCanBeZero::from(r);
        (ga, ProofInv { ga_inv, gc, s })
    }

    #[must_use]
    pub fn verify_proof_split_inv(ga: &GroupElement, ga_inv: &GroupElement, gc: &GroupElement, s: &ScalarCanBeZero) -> bool {
        let mut hasher = Sha512::default();
        hasher.update(ga.0.compress().as_bytes());
        hasher.update(ga_inv.0.compress().as_bytes());
        hasher.update(gc.0.compress().as_bytes());
        let mut bytes = [0u8; 64];
        bytes.copy_from_slice(hasher.finalize().as_slice());
        let e = ScalarNonZero::from_hash(&bytes);

        debug_assert_eq!(s * G, e * ga_inv + gc);
        s * G == e * ga_inv + gc
    }

    #[must_use]
    pub fn verify_proof_inv(ga: &GroupElement, p: &ProofInv) -> bool {
        verify_proof_split_inv(ga, &p.ga_inv, &p.gc, &p.s)
    }

//// SIGNATURES

    type Signature = Proof;

    pub fn sign<R: RngCore + CryptoRng>(message: &GroupElement, secret_key: &ScalarNonZero, rng: &mut R) -> Signature {
        create_proof(secret_key, message, rng).1
    }

    #[must_use]
    pub fn verify(message: &GroupElement, p: &Signature, public_key: &GroupElement) -> bool {
        verify_proof(public_key, message, p)
    }

//// RERANDOMIZE

    // We are re-using some variables from the Proof to reconstruct the Rerandomize operation.
// This way, we only need 1 Proof object (which are fairly large)
    type ProvedRerandomize = (GroupElement, Proof);

    pub fn prove_rerandomize<R: RngCore + CryptoRng>(v: &ElGamal, s: &ScalarNonZero, rng: &mut R) -> ProvedRerandomize {
        // Rerandomize is normally {s * G + in.b, s*in.y + in.c, in.y};
        create_proof(s, &v.y, rng)
    }

    #[must_use]
    pub fn verify_rerandomize(v: &ElGamal, p: &ProvedRerandomize) -> Option<ElGamal> {
        verify_rerandomize_split(&v.b, &v.c, &v.y, &p.0, &p.1)
    }

    #[must_use]
    pub fn verify_rerandomize_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gs: &GroupElement, p: &Proof) -> Option<ElGamal> {
        // slightly different than the others, as we reuse the structure of a standard proof to reconstruct the Rerandomize operation after sending
        if verify_proof(gs, gy, p) {
            Some(ElGamal {
                b: gs + gb,
                c: **p + gc,
                y: *gy
            })
        } else {
            None
        }
    }

//// RESHUFFLE

    /// GroupElement is `n*G` if prove_reshuffle with `n` is called.
    pub struct ProvedReshuffle(pub GroupElement, pub Proof, pub Proof);

    pub fn prove_reshuffle<R: RngCore + CryptoRng>(v: &ElGamal, n: &ScalarNonZero, rng: &mut R) -> ProvedReshuffle {
        // Reshuffle is normally {n * in.b, n * in.c, in.y};
        // NOTE: can be optimised a bit, by fusing the two CreateProofs (because same n is used, saving a n*G operation)
        let (ab, pb) = create_proof(n, &v.b, rng);
        let (ac, pc) = create_proof(n, &v.c, rng);
        debug_assert_eq!(ab, ac);
        ProvedReshuffle(ab, pb, pc)
    }

    #[must_use]
    pub fn verify_reshuffle(v: &ElGamal, p: &ProvedReshuffle) -> Option<ElGamal> {
        verify_reshuffle_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2)
    }

    #[must_use]
    pub fn verify_reshuffle_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gab: &GroupElement, pb: &Proof, pc: &Proof) -> Option<ElGamal> {
        if verify_proof(gab, gb, pb) && verify_proof(gab, gc, pc) {
            Some(ElGamal {
                b: **pb,
                c: **pc,
                y: *gy,
            })
        } else {
            None
        }
    }

    impl ProvedReshuffle {
        /// Returns `n*G` after `prove_reshuffle(in, n)`.
        pub fn reshuffled_by(&self) -> GroupElement {
            self.0
        }
    }

    pub struct ProvedReshuffleFromTo(pub GroupElement, pub GroupElement, pub GroupElement, pub ProofInv, pub Proof, pub Proof, pub Proof);

    pub fn prove_reshuffle_from_to<R: RngCore + CryptoRng>(v: &ElGamal, n_from: &ScalarNonZero, n_to: &ScalarNonZero, rng: &mut R) -> ProvedReshuffleFromTo {
        // Reshuffle is normally {n_from^-1 * n_to * in.b, n_from^-1 * n_to * in.c, in.y};
        let n = n_from.invert() * n_to;
        let (gn_from, p_n_from_inv) = create_proof_inv(&n_from, rng);
        let gn_from_inv = p_n_from_inv.ga_inv;
        let (gn_to, p_n_from_inv_n_to) = create_proof(&n_to, &*p_n_from_inv, rng);
        let (ab, pb) = create_proof(&n, &v.b, rng);
        let (ac, pc) = create_proof(&n, &v.c, rng);
        debug_assert_eq!(ab, ac);
        debug_assert_eq!(ab, n * G);
        ProvedReshuffleFromTo(gn_from, gn_from_inv, gn_to, p_n_from_inv, p_n_from_inv_n_to, pb, pc)
    }

    #[must_use]
    pub fn verify_reshuffle_from_to(v: &ElGamal, p: &ProvedReshuffleFromTo) -> Option<ElGamal> {
        verify_reshuffle_from_to_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3, &p.4, &p.5, &p.6)
    }

    #[must_use]
    pub fn verify_reshuffle_from_to_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gn_from: &GroupElement, gn_from_inv: &GroupElement, gn_to: &GroupElement, p_n_from_inv: &ProofInv, p_n_from_inv_n_to: &Proof, pb: &Proof, pc: &Proof) -> Option<ElGamal> {
        if verify_proof_inv(&gn_from, &p_n_from_inv) && verify_proof(&gn_to, &*p_n_from_inv, &p_n_from_inv_n_to) && verify_proof(p_n_from_inv_n_to, gb, pb) && verify_proof(p_n_from_inv_n_to, gc, pc) && p_n_from_inv.ga_inv == *gn_from_inv {
            Some(ElGamal {
                b: **pb,
                c: **pc,
                y: *gy,
            })
        } else {
            None
        }
    }

    impl ProvedReshuffleFromTo {
        pub fn reshuffled_by_from(&self) -> GroupElement {
            self.0
        }
        pub fn reshuffled_by_from_inv(&self) -> GroupElement {
            self.1
        }
        pub fn reshuffled_by_to(&self) -> GroupElement {
            self.2
        }
    }


//// REKEY

    /// Second GroupElement is `k*G` if prove_rekey with `k` is called.
    pub struct ProvedRekey(pub GroupElement, pub Proof, pub GroupElement, pub Proof);

    pub fn prove_rekey<R: RngCore + CryptoRng>(v: &ElGamal, k: &ScalarNonZero, rng: &mut R) -> ProvedRekey {
        // Rekey is normally {in.b/k, in.c, k*in.y};
        let (ab, pb) = create_proof(&k.invert(), &v.b, rng);
        let (ay, py) = create_proof(k, &v.y, rng);
        ProvedRekey(ab, pb, ay, py)
    }

    #[must_use]
    pub fn verify_rekey(v: &ElGamal, p: &ProvedRekey) -> Option<ElGamal> {
        verify_rekey_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3)
    }

    #[must_use]
    pub fn verify_rekey_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gab: &GroupElement, pb: &Proof, gay: &GroupElement, py: &Proof) -> Option<ElGamal> {
        if verify_proof(gab, gb, pb) && verify_proof(gay, gy, py) {
            Some(ElGamal {
                b: **pb,
                c: *gc,
                y: **py,
            })
        } else {
            None
        }
    }

    impl ProvedRekey {
        /// Returns `k*G` after `prove_rekey(in, k)`.
        pub fn rekeyed_by(&self) -> GroupElement {
            self.2
        }
    }

//// RKS

    /// First GroupElement is `n*G` if prove_rks with `n` is called.
    /// Second GroupElement is `k*G` if prove_rks with `k` is called.
    pub struct ProvedRKS(pub GroupElement, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof);

    pub fn prove_rks<R: RngCore + CryptoRng>(v: &ElGamal, k: &ScalarNonZero, n: &ScalarNonZero, rng: &mut R) -> ProvedRKS {
        // RKS is normally {(n / k) * in.B, n * in.C, k * in.Y};
        let a = create_proof(&(n * k.invert()), &v.b, rng);
        let b = create_proof(n, &v.c, rng);
        let c = create_proof(k, &v.y, rng);
        // different order so that first and second group elements for prove_reshuffle,
        // prove_rekey, prove_rks have the same meaning
        ProvedRKS(b.0, b.1, c.0, c.1, a.0, a.1)
    }

    #[must_use]
    pub fn verify_rks(v: &ElGamal, p: &ProvedRKS) -> Option<ElGamal> {
        verify_rks_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3, &p.4, &p.5)
    }

    #[must_use]
    #[allow(clippy::too_many_arguments)]
    pub fn verify_rks_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gac: &GroupElement, pc: &Proof, gay: &GroupElement, py: &Proof, gab: &GroupElement, pb: &Proof) -> Option<ElGamal> {
        if verify_proof(gab, gb, pb) && verify_proof(gac, gc, pc) && verify_proof(gay, gy, py) {
            Some(ElGamal {
                b: **pb,
                c: **pc,
                y: **py,
            })
        } else {
            None
        }
    }

    impl ProvedRKS {
        /// Returns `n*G` after `prove_rks(in, k, n)`.
        pub fn reshuffled_by(&self) -> GroupElement {
            self.0
        }
        /// Returns `k*G` after `prove_rks(in, k, n)`.
        pub fn rekeyed_by(&self) -> GroupElement {
            self.2
        }
    }

    pub struct ProvedRKSFromTo(pub GroupElement, pub GroupElement, pub GroupElement, pub ProofInv, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof);

    pub fn prove_rks_from_to<R: RngCore + CryptoRng>(v: &ElGamal, k: &ScalarNonZero, n_from: &ScalarNonZero, n_to: &ScalarNonZero, rng: &mut R) -> ProvedRKSFromTo {
        // RKS is normally {(n_from^-1 * n_to / k) * in.B, n_from^-1 * n_to * in.C, k * in.Y};
        let n = n_from.invert() * n_to;
        let (gn_from, p_n_from_inv) = create_proof_inv(&n_from, rng);
        let gn_from_inv = p_n_from_inv.ga_inv;
        let (gn_to, p_n_from_inv_n_to) = create_proof(&n_to, &*p_n_from_inv, rng);

        let a = create_proof(&(n * k.invert()), &v.b, rng);
        let b = create_proof(&n, &v.c, rng);
        let c = create_proof(k, &v.y, rng);
        // different order so that first and second group elements for prove_reshuffle,
        // prove_rekey, prove_rks have the same meaning

        ProvedRKSFromTo(gn_from, gn_from_inv, gn_to, p_n_from_inv, p_n_from_inv_n_to, b.0, b.1, c.0, c.1, a.0, a.1)
    }

    #[must_use]
    pub fn verify_rks_from_to(v: &ElGamal, p: &ProvedRKSFromTo) -> Option<ElGamal> {
        verify_rks_from_to_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3, &p.4, &p.5, &p.6, &p.7, &p.8, &p.9, &p.10)
    }

    #[must_use]
    #[allow(clippy::too_many_arguments)]
    pub fn verify_rks_from_to_split(gb: &GroupElement, gc: &GroupElement, gy: &GroupElement, gn_from: &GroupElement, gn_from_inv: &GroupElement, gn_to: &GroupElement, p_n_from_inv: &ProofInv, p_n_from_inv_n_to: &Proof, gac: &GroupElement, pc: &Proof, gay: &GroupElement, py: &Proof, gab: &GroupElement, pb: &Proof) -> Option<ElGamal> {
        if verify_proof_inv(&gn_from, &p_n_from_inv) && verify_proof(&gn_to, &*p_n_from_inv, &p_n_from_inv_n_to) && verify_proof(gab, gb, pb) && verify_proof(gac, gc, pc) && verify_proof(gay, gy, py) && p_n_from_inv.ga_inv == *gn_from_inv {
            Some(ElGamal {
                b: **pb,
                c: **pc,
                y: **py,
            })
        } else {
            None
        }
    }

    impl ProvedRKSFromTo {
        pub fn reshuffled_by_from(&self) -> GroupElement {
            self.0
        }
        pub fn reshuffled_by_from_inv(&self) -> GroupElement {
            self.1
        }
        pub fn reshuffled_by_to(&self) -> GroupElement {
            self.2
        }
        pub fn rekeyed_by(&self) -> GroupElement {
            self.7
        }
    }

    pub struct ProvedRRKSFromTo(pub GroupElement, pub GroupElement, pub GroupElement, pub GroupElement, pub GroupElement, pub GroupElement, pub ProofInv, pub Proof, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof, pub GroupElement, pub Proof);

    pub fn prove_rrks_from_to<R: RngCore + CryptoRng>(v: &ElGamal, s: &ScalarNonZero, k: &ScalarNonZero, n_from: &ScalarNonZero, n_to: &ScalarNonZero, rng: &mut R) -> crate::zkp::ProvedRRKSFromTo {
        // RRKS is {(s * n / k * G) + ((n / k) * in.B), (n * s * in.y) + n * in.C, k * in.Y};
        let n = n_from.invert() * n_to;
        let (gn_from, p_n_from_inv) = create_proof_inv(&n_from, rng);
        let gn_from_inv = p_n_from_inv.ga_inv;
        let (gn_to, p_n) = create_proof(&n_to, &gn_from_inv, rng);
        let gn = p_n.n;
        let (gs, p_n_s) = create_proof(&s, &gn, rng);
        let gn_s = p_n_s.n;

        let (gs_n_kinv, pb1) = create_proof(&(s * n * k.invert()), &G, rng); // I think this can be removed
        let (gs_n_k_b, pb2) = create_proof(&(n * k.invert()), &v.b, rng);
        let (gs_n_y, pc1) = create_proof(&(n * s), &v.y, rng);
        let (gn_c, pc2) = create_proof(&n, &v.c, rng);
        let (gk_y, py) = create_proof(k, &v.y, rng);

        crate::zkp::ProvedRRKSFromTo(gn_from, gn_from_inv, gn_to, gn, gs, gn_s,
                                     p_n_from_inv, p_n, p_n_s,
                                     gs_n_y, pc1, gn_c, pc2, gk_y, py, gs_n_kinv, pb1, gs_n_k_b, pb2)
    }

    #[must_use]
    pub fn verify_rrks_from_to(v: &ElGamal, p: &crate::zkp::ProvedRRKSFromTo) -> Option<ElGamal> {
        crate::zkp::verify_rrks_from_to_split(&v.b, &v.c, &v.y, &p.0, &p.1, &p.2, &p.3, &p.4, &p.5, &p.6, &p.7, &p.8, &p.9, &p.10, &p.11, &p.12, &p.13, &p.14, &p.15, &p.16, &p.17, &p.18)
    }

    #[must_use]
    #[allow(clippy::too_many_arguments)]
    pub fn verify_rrks_from_to_split(
        gb: &GroupElement,
        gc: &GroupElement,
        gy: &GroupElement,
        gn_from: &GroupElement,
        gn_from_inv: &GroupElement,
        gn_to: &GroupElement,
        gn: &GroupElement,
        gs: &GroupElement,
        gn_s: &GroupElement,
        p_n_from_inv: &ProofInv,
        p_n: &Proof,
        p_n_s: &Proof,
        gs_n_y: &GroupElement,
        pc1: &Proof,
        gn_c: &GroupElement,
        pc2: &Proof,
        gk_y: &GroupElement,
        py: &Proof,
        gs_n_kinv: &GroupElement,
        pb1: &Proof,
        gs_n_k_b: &GroupElement,
        pb2: &Proof,
    ) -> Option<ElGamal> {
        if verify_proof_inv(&gn_from, &p_n_from_inv)
            && verify_proof(&gn_to, &*p_n_from_inv, &p_n)
            && verify_proof(&gs, &*p_n, &p_n_s)

            && verify_proof(&gs_n_y, gy, &pc1)
            && verify_proof(&gn_c, gc, &pc2)
            && verify_proof(&gk_y, gy, &py)
            // && verify_proof(gs_n_kinv, &G, &pb1) // TODO remove
            && verify_proof(gs_n_k_b, gb, &pb2)

            // && p_n_from_inv.ga_inv == *gn_from_inv
            // && *gs_n_kinv == **pb1
            // && *gs_n_k_b == **pb2
            // && *gs_n_y == **pc1
            // && *gn_c == **pc2
            // && *gk_y == **py
        {
            Some(ElGamal {
                b: **pb1 + **pb2,
                c: **pc1 + **pc2,
                y: **py,
            })
        } else {
            None
        }
    }
    impl crate::zkp::ProvedRRKSFromTo {
        pub fn reshuffled_by_from(&self) -> GroupElement {
            self.0
        }
        pub fn reshuffled_by_from_inv(&self) -> GroupElement {
            self.1
        }
        pub fn reshuffled_by_to(&self) -> GroupElement {
            self.2
        }
        pub fn rekeyed_by(&self) -> GroupElement {
            self.13
        }
    }

}



/// Higher lever API for simple pseudonimisation on a single host.
pub mod simple {

use crate::*;

type GlobalPublicKey = GroupElement;
type GlobalSecretKey = ScalarNonZero;
type GlobalEncryptedPseudonym = ElGamal;
type LocalEncryptedPseudonym = ElGamal;
type LocalPseudonym = GroupElement;
type LocalDecryptionKey = ScalarNonZero;

pub fn generate_global_keys<R: RngCore + CryptoRng>(rng: &mut R) -> (GlobalPublicKey, GlobalSecretKey) {
    // secret key of system
    let y = ScalarNonZero::random(rng);
    // public key of system
    let gy = y*G;
    (gy, y)
}

/// Generates a non-zero scalar.
fn make_factor(typ: &str, secret: &str, context: &str) -> ScalarNonZero {
    let mut hasher = Sha512::default();
    hasher.update(typ.as_bytes());
    hasher.update(b"|");
    hasher.update(secret.as_bytes());
    hasher.update(b"|");
    hasher.update(context.as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    ScalarNonZero::from_hash(&bytes)
}

/// Generates a non-zero scalar.
pub(crate) fn make_pseudonymisation_factor(secret: &str, context: &str) -> ScalarNonZero {
  make_factor("pseudonym", secret, context)
}

/// Generates a non-zero scalar.
pub fn make_decryption_factor(secret: &str, context: &str) -> ScalarNonZero {
  make_factor("decryption", secret, context)
}

/// Generates a encrypted global pseudonym by encrypting a text with ElGamal using the global
/// public key `pkg`.
pub fn generate_pseudonym<R: RngCore + CryptoRng>(identity: &str, pk: &GlobalPublicKey, rng: &mut R) -> GlobalEncryptedPseudonym {
    let mut hasher = Sha512::default();
    hasher.update(identity.as_bytes());
    let mut bytes = [0u8; 64];
    bytes.copy_from_slice(hasher.finalize().as_slice());
    let p = GroupElement::from_hash(&bytes);
    encrypt(&p, pk, rng)
}

/// Using a PEP `rks` operation, convert a global encrypted pseudonym to a local encrypted pseudonym,
/// which is:
/// - decryptable with the key `k` that is generated by [make_local_decryption_key] using the same
///   `decryption_context`;
/// - decrypts to the pseudonym that is the global pseudonym multiplied by a factor specific to the
///   `pseudonimisation_context`.
pub fn convert_to_local_pseudonym(p: &GlobalEncryptedPseudonym, secret: &str, decryption_context: &str, pseudonimisation_context: &str) -> LocalEncryptedPseudonym {
    let u = make_pseudonymisation_factor(secret, pseudonimisation_context);
    let t = make_decryption_factor(secret, decryption_context);
    rks(p, &t, &u)
}

pub fn convert_from_local_pseudonym(p: &LocalEncryptedPseudonym, secret: &str, decryption_context: &str, pseudonimisation_context: &str) -> GlobalEncryptedPseudonym {
    let u = make_pseudonymisation_factor(secret, pseudonimisation_context).invert();
    let t = make_decryption_factor(secret, decryption_context).invert();
    rks(p, &t, &u)
}

pub fn make_local_decryption_key(k: &GlobalSecretKey, secret: &str, decryption_context: &str) -> LocalDecryptionKey {
    let t = make_decryption_factor(secret, decryption_context);
    t*k
}

pub fn decrypt_local_pseudonym(p: &LocalEncryptedPseudonym, k: &LocalDecryptionKey) -> LocalPseudonym {
    decrypt(p, k)
}

pub fn rerandomize_global<R: RngCore + CryptoRng>(p: &GlobalEncryptedPseudonym, rng: &mut R) -> GlobalEncryptedPseudonym {
    rerandomize(p, &ScalarNonZero::random(rng))
}

pub fn rerandomize_local<R: RngCore + CryptoRng>(p: &LocalEncryptedPseudonym, rng: &mut R) -> LocalEncryptedPseudonym {
    rerandomize(p, &ScalarNonZero::random(rng))
}

}

pub mod distributed {
    use std::collections::HashMap;
    use crate::*;
    use crate::zkp::*;
    use crate::simple::*;
    use crate::libpep::encode_hex;

    pub type GlobalPublicKey = GroupElement;
    pub type GlobalSecretKey = ScalarNonZero;
    pub type BlindedGlobalSecretKey = ScalarNonZero;
    pub type DecryptionKeyPart = ScalarNonZero;

    pub type Message = ElGamal;
    pub type Context = String;
    pub type SystemId = String;
    pub struct TrustedGroupElementCache {
        pub cache: HashMap<(SystemId, Context), GroupElement>,
    }
    impl TrustedGroupElementCache {
        fn new() -> Self {
            TrustedGroupElementCache {
                cache: HashMap::new(),
            }
        }
        fn store(&mut self, system_id: SystemId, context: Context, element: GroupElement) {
            self.cache.insert((system_id, context), element);
        }
        fn retrieve(&self, system_id: &SystemId, context: &Context) -> Option<&GroupElement> {
            self.cache.get(&(system_id.to_string(), context.to_string()))
        }
        fn contains(&self, element: &GroupElement) -> bool {
            self.cache.values().any(|x| x == element)
        }
    }
    pub struct PEPSystem {
        pub system_id: String,
        pub config: PEPNetworkConfig,
        pseudonymisation_secret: String,
        rekeying_secret: String,
        blinding_factor: ScalarNonZero,
        pub trusted_pseudonymisation_factors: TrustedGroupElementCache,
        pub trusted_inv_pseudonymisation_factors: TrustedGroupElementCache,
        pub trusted_rekeying_factors: TrustedGroupElementCache,
    }
    pub struct PEPNetworkConfig {
        pub global_public_key: GlobalPublicKey,
        pub blinded_global_private_key: ScalarNonZero,
        pub system_ids: Vec<String>,
    }
    impl PEPNetworkConfig {
        pub fn new(global_public_key: GlobalPublicKey, blinded_global_private_key: BlindedGlobalSecretKey, system_ids: Vec<SystemId>) -> Self {
            Self {
                global_public_key,
                blinded_global_private_key,
                system_ids,
            }
        }
    }
    impl PEPSystem {
        pub fn new(system_id: SystemId, config: PEPNetworkConfig, pseudonymisation_secret: String, rekeying_secret: String, blinding_factor: ScalarNonZero) -> Self {
            Self {
                system_id,
                config,
                pseudonymisation_secret,
                rekeying_secret,
                blinding_factor,
                trusted_pseudonymisation_factors: TrustedGroupElementCache::new(),
                trusted_inv_pseudonymisation_factors: TrustedGroupElementCache::new(),
                trusted_rekeying_factors: TrustedGroupElementCache::new(),
            }
        }
        fn verify_system_pseudonymize(&mut self, system_id: &SystemId, msg_in: &Message, proved_rks: &ProvedRKSFromTo, pc_from: &Context, pc_to: &Context, dc: &Context) -> Result<Message, &'static str> {
            let trusted_from = self.trusted_pseudonymisation_factors.retrieve(system_id, pc_from);
            let trusted_from_inv = self.trusted_inv_pseudonymisation_factors.retrieve(system_id, pc_from);
            let trusted_to = self.trusted_pseudonymisation_factors.retrieve(system_id, pc_to);
            let trusted_k = self.trusted_rekeying_factors.retrieve(system_id, dc);

            let msg_out = verify_rks_from_to(msg_in, proved_rks);

            if msg_out.is_none() {
                return Err("invalid proof")
            }

            if trusted_from.is_some() && proved_rks.reshuffled_by_from() != *trusted_from.unwrap()
                || trusted_from_inv.is_some() && proved_rks.reshuffled_by_from_inv() != *trusted_from_inv.unwrap()
                || trusted_to.is_some() &&  proved_rks.reshuffled_by_to() != *trusted_to.unwrap()
                || trusted_k.is_some() && proved_rks.rekeyed_by() != *trusted_k.unwrap() {
                return Err("inconsistent factors used")
            }

            if proved_rks.reshuffled_by_from() == GroupElement::identity() || proved_rks.reshuffled_by_from_inv() == GroupElement::identity() || proved_rks.reshuffled_by_to() == GroupElement::identity() || proved_rks.rekeyed_by() == GroupElement::identity(){
                return Err("forbidden factors used")
            }

            if self.trusted_inv_pseudonymisation_factors.contains(&proved_rks.reshuffled_by_from()) || self.trusted_inv_pseudonymisation_factors.contains(&proved_rks.reshuffled_by_to()) {
                return Err("inverse factors used")
            }

            self.trusted_pseudonymisation_factors.store(system_id.clone(), pc_from.clone(), proved_rks.reshuffled_by_from());
            self.trusted_inv_pseudonymisation_factors.store(system_id.clone(), pc_from.clone(), proved_rks.reshuffled_by_from_inv());
            self.trusted_pseudonymisation_factors.store(system_id.clone(), pc_to.clone(), proved_rks.reshuffled_by_to());
            self.trusted_rekeying_factors.store(system_id.clone(), dc.clone(), proved_rks.rekeyed_by());

            Ok(msg_out.unwrap())
        }
        pub fn verify_pseudonymize(&mut self, messages: &Vec<(SystemId,Message,ProvedRKSFromTo)>, pc_from: &Context, pc_to: &Context, dc: &Context) -> Result<Message, &'static str> {
            let mut msg_out = None;
            let mut visited_systems = Vec::new();
            for (system_id, msg_in, proved_rks) in messages {
                if !self.config.system_ids.contains(&String::from(system_id)) {
                    return Err("invalid system id");
                }
                if visited_systems.contains(&system_id) {
                    return Err("system visited twice");
                }
                if msg_out.is_some() && msg_out.unwrap() != *msg_in{
                    return Err("inconsistent messages");
                }
                let verification = self.verify_system_pseudonymize(&system_id, &msg_in, &proved_rks, pc_from, pc_to, dc);
                if verification.is_err() {
                    return verification
                }
                msg_out = Some(verification.unwrap());
                visited_systems.push(system_id);
            }
            Ok(msg_out.unwrap())
        }
        fn verify_system_transcrypt(&mut self, system_id: &SystemId, msg_in: &Message, proved_rekey: &ProvedRekey, dc: &Context) -> Result<Message, &'static str> {
            let trusted_k = self.trusted_rekeying_factors.retrieve(system_id, dc);
            let msg_out = verify_rekey(msg_in, proved_rekey);
            if msg_out.is_none() {
                return Err("invalid proof")
            }

            if trusted_k.is_some() && proved_rekey.rekeyed_by() != *trusted_k.unwrap() {
                return Err("inconsistent factors used")
            }

            if proved_rekey.rekeyed_by() == GroupElement::identity() {
                return Err("forbidden factors used")
            }

            self.trusted_rekeying_factors.store(system_id.clone(), dc.clone(), proved_rekey.rekeyed_by());

            Ok(msg_out.unwrap())
        }
        pub fn verify_transcrypt(&mut self, messages: &Vec<(SystemId,Message,ProvedRekey)>, dc: &Context) -> Result<Message, &'static str> {
            let mut msg_out = None;
            let mut visited_systems = Vec::new();
            for (system_id, msg_in, proved_rekey) in messages {
                if !self.config.system_ids.contains(&String::from(system_id)) {
                    return Err("invalid system id");
                }
                if visited_systems.contains(&system_id) {
                    return Err("system visited twice");
                }
                if msg_out.is_some() && msg_out.unwrap() != *msg_in{
                    return Err("inconsistent messages");
                }
                let verification = self.verify_system_transcrypt(&system_id, &msg_in, &proved_rekey, dc);
                if verification.is_err() {
                    return verification
                }
                msg_out = Some(verification.unwrap());
                visited_systems.push(system_id);
            }
            Ok(msg_out.unwrap())
        }
        pub fn pseudonymize<R: RngCore + CryptoRng>(&mut self, message: &Message, pc_from: &Context, pc_to: &Context, dc: &Context, rng: &mut R) -> ProvedRKSFromTo {
            let n_from = make_pseudonymisation_factor(&self.pseudonymisation_secret, pc_from);
            let n_to = make_pseudonymisation_factor(&self.pseudonymisation_secret, pc_to);
            let k = make_decryption_factor(&self.rekeying_secret, dc);
            prove_rks_from_to(message, &k, &n_from, &n_to, rng)
        }
        pub fn transcrypt<R: RngCore + CryptoRng>(&mut self, message: &Message, dc: &Context, rng: &mut R) -> ProvedRekey {
            let k = make_decryption_factor(&self.rekeying_secret, dc);
            prove_rekey(message, &k, rng)
        }
        pub fn decryption_key_part(&self, dc: &Context) -> DecryptionKeyPart {
            let k = make_decryption_factor(&self.rekeying_secret, dc);
            k * &self.blinding_factor.invert()
        }
    }
}
#[cfg(test)]
mod libpep {
    use crate::*;
    use crate::zkp::*;
    use crate::simple::*;
    use crate::distributed::*;
    use rand_core::OsRng;

    #[test]
    fn elgamal_encryption() {
        let mut rng = OsRng;
        // secret key
        let s = ScalarNonZero::random(&mut rng);
        // public key
        let p = s * G;

        // choose a random value to encrypt
        let value = GroupElement::random(&mut rng);

        // encrypt/decrypt this value
        let encrypted = encrypt(&value, &p, &mut OsRng);
        let decrypted = decrypt(&encrypted, &s);

        assert_eq!(value, decrypted);


        let encoded = encrypted.encode();
        let decoded = ElGamal::decode(&encoded);

        assert_eq!(Some(encrypted), decoded);
    }

    #[test]
    fn pep_assumptions() {
        let mut rng = OsRng;
        // secret key of system
        let sk = ScalarNonZero::random(&mut rng);
        // public key of system
        let pk = sk * G;

        // secret key of service provider
        let sj = ScalarNonZero::random(&mut rng);
        let yj = sj * sk;
        assert_eq!(yj * G, sj * pk);

        // Lemma 2: RS(RK(..., k), n) == RK(RS(..., n), k)
        let value = GroupElement::random(&mut rng);
        let encrypted = encrypt(&value, &pk, &mut OsRng);
        let k = ScalarNonZero::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);
        assert_eq!(reshuffle(&rekey(&encrypted, &k), &n), rekey(&reshuffle(&encrypted, &n), &k));
        assert_eq!(reshuffle(&rekey(&encrypted, &k), &n), rks(&encrypted, &k, &n));
    }

    #[test]
    fn elgamal_signature() {
        let mut rng = OsRng;
        // secret key
        let s = ScalarNonZero::random(&mut rng);
        let s2 = ScalarNonZero::random(&mut rng);
        // public key
        let gp = s * G;

        let v = GroupElement::random(&mut rng);
        let mut signature = sign(&v, &s, &mut rng);
        assert!(verify(&v, &signature, &gp));

        signature = sign(&v, &s2, &mut rng);
        assert!(!verify(&v, &signature, &gp));
    }

    #[test]
    fn pep_schnorr_basic_offline() {
        let mut rng = OsRng;
        // given a secret a and public M, proof that a certain triplet (A, M, N) is actually calculated by (a*G, M, a * M)
        // using Fiat-Shamir transform

        // prover
        let a = ScalarNonZero::random(&mut rng);
        let gm = GroupElement::random(&mut rng);

        let (ga, p) = create_proof(&a, &gm, &mut rng);
        assert_eq!(a * gm, *p);

        // verifier
        assert!(verify_proof(&ga, &gm, &p));
    }

    #[test]
    fn pep_schnorr_basic_offline_inv() {
        let mut rng = OsRng;
        // prover
        let a = ScalarNonZero::random(&mut rng);

        let (ga, p) = create_proof_inv(&a, &mut rng); // Use a instead of a_inverse
        assert_eq!(a.invert() * G, *p);

        // verifier
        assert!(verify_proof_inv(&ga, &p));
    }

    #[test]
    fn pep_schnorr_basic_offline_from_to() {
        let mut rng = OsRng;
        // given secret a1, a2 and public Min, proof that a certain triplet (A1, A2, M, N) is actually calculated by (a1 * G, a2 * G, M, a1.inv() * a2 * M)
        // using Fiat-Shamir transform

        // prover
        let a1 = ScalarNonZero::random(&mut rng);
        let a2 = ScalarNonZero::random(&mut rng);
        let a1_inv = a1.invert();

        let ga1 = a1 * G;
        let ga2 = a2 * G;

        let min = GroupElement::random(&mut rng);

        let (_ga1, p_a1_inv) = create_proof_inv(&a1, &mut rng);
        let (_ga1_inv_a2, p_a1_inv_a2) = create_proof(&a2,&*p_a1_inv, &mut rng);
        let (_ga1_inv_a2_min, p_a1_inv_a2_min) = create_proof(&(a1_inv*a2),&min, &mut rng);

        assert_eq!(a1_inv * G, *p_a1_inv);
        assert_eq!(a1_inv*a2 * G, *p_a1_inv_a2);
        assert_eq!(a1_inv*a2 * min, *p_a1_inv_a2_min);

        // verifier
        assert!(verify_proof_inv(&ga1, &p_a1_inv));
        assert!(verify_proof(&ga2, &*p_a1_inv, &p_a1_inv_a2));
        assert!(verify_proof(&*p_a1_inv_a2, &min, &p_a1_inv_a2_min));

        // first we proof to know a scalar that is indeed the inverse of a1, based on A1
        // then we proof to know a different scalar that is a1*^-1 * a2, based on A2
        // finally, we proof that our message M was multiplied by that number.
    }

    #[test]
    fn pep_schnorr_rerandomize() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let s = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rerandomize(&msg, &s, &mut rng);

        let checked = verify_rerandomize(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&rerandomize(&msg, &s), checked.as_ref().unwrap());
    }

    #[test]
    fn pep_schnorr_reshuffle() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_reshuffle(&msg, &n, &mut rng);

        let checked = verify_reshuffle(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(n*gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&reshuffle(&msg, &n), checked.as_ref().unwrap());
        assert_eq!(n*G, proved.reshuffled_by());
    }

    #[test]
    fn pep_schnorr_reshuffle_from_to() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let n_from = ScalarNonZero::random(&mut rng);
        let n_to = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_reshuffle_from_to(&msg, &n_from, &n_to, &mut rng);

        let checked = verify_reshuffle_from_to(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(n_from.invert()*n_to*gm, decrypt(checked.as_ref().unwrap(), &y));
        assert_eq!(&reshuffle(&msg, &(n_from.invert()*n_to)), checked.as_ref().unwrap());
        assert_eq!(n_from*G, proved.reshuffled_by_from());
        assert_eq!(n_to*G, proved.reshuffled_by_to());
    }


    #[test]
    fn pep_schnorr_rekey() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rekey(&msg, &k, &mut rng);
        let checked = verify_rekey(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(proved.rekeyed_by(), k*G);
        assert_eq!(gm, decrypt(checked.as_ref().unwrap(), &(k*y)));
    }

    #[test]
    fn pep_schnorr_rks() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);
        let n = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rks(&msg, &k, &n, &mut rng);

        let checked = verify_rks(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(proved.rekeyed_by(), k*G);
        assert_eq!(n*gm, decrypt(checked.as_ref().unwrap(), &(k*y)));
    }

    #[test]
    fn pep_schnorr_rks_from_to() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);
        let n_from = ScalarNonZero::random(&mut rng);
        let n_to = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rks_from_to(&msg, &k, &n_from, &n_to, &mut rng);

        let checked = verify_rks_from_to(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(proved.rekeyed_by(), k*G);
        assert_eq!(n_from.invert()*n_to*gm, decrypt(checked.as_ref().unwrap(), &(k*y)));
        assert_eq!(n_from*G, proved.reshuffled_by_from());
        assert_eq!(n_to*G, proved.reshuffled_by_to());
    }

    #[test]
    fn pep_schnorr_rrks_from_to() {
        let mut rng = OsRng;
        // secret key of system
        let y = ScalarNonZero::random(&mut rng);
        // public key of system
        let gy = y*G;

        let gm = GroupElement::random(&mut rng);
        let k = ScalarNonZero::random(&mut rng);
        let n_from = ScalarNonZero::random(&mut rng);
        let n_to = ScalarNonZero::random(&mut rng);
        let s1 = ScalarNonZero::random(&mut rng);

        let msg = encrypt(&gm, &gy, &mut rng);

        let proved = prove_rrks_from_to(&msg, &s1, &k, &n_from, &n_to, &mut rng);

        let checked = verify_rrks_from_to(&msg, &proved);

        assert!(checked.is_some());
        assert_ne!(&msg, checked.as_ref().unwrap());
        assert_eq!(proved.rekeyed_by(), k*G);
        assert_eq!(n_from.invert()*n_to*gm, decrypt(checked.as_ref().unwrap(), &(k*y)));
        assert_eq!(n_from*G, proved.reshuffled_by_from());
        assert_eq!(n_to*G, proved.reshuffled_by_to());

        let s2= ScalarNonZero::random(&mut rng);

        let proved2 = prove_rrks_from_to(&msg, &s2, &k, &n_from, &n_to, &mut rng);

        let checked2 = verify_rrks_from_to(&msg, &proved2);
        assert!(checked2.is_some());
        assert_ne!(checked, checked2); // messages should be different because of the rerandomization
        assert_eq!(proved2.rekeyed_by(), k*G);
        assert_eq!(n_from*G, proved2.reshuffled_by_from());
        assert_eq!(n_to*G, proved2.reshuffled_by_to());
    }

    // https://stackoverflow.com/questions/52987181/how-can-i-convert-a-hex-string-to-a-u8-slice
    use std::{fmt::Write, num::ParseIntError};

    pub fn decode_hex(s: &str) -> Result<Vec<u8>, ParseIntError> {
        (0..s.len())
            .step_by(2)
            .map(|i| u8::from_str_radix(&s[i..i + 2], 16))
            .collect()
    }
    #[allow(dead_code)]
    pub fn encode_hex(bytes: &[u8]) -> String {
        let mut s = String::with_capacity(bytes.len() * 2);
        for &b in bytes {
            write!(&mut s, "{:02x}", b).unwrap();
        }
        s
    }

    #[test]
    fn pep_high_level_api() {
        let mut rng = OsRng;
        let (public_key, secret_key) = generate_global_keys(&mut rng);
        //std::cout << "global public key: " << publicKey.hex() << std::endl;
        //std::cout << "global secret key: " << secretKey.hex() << std::endl;

        let id = "foobar";
        let mut gep = generate_pseudonym(id, &public_key, &mut rng);
        //gep = GlobalEncryptedPseudonym::FromHex(gep.hex());
        //std::cout << "global pseudonym for '" << id << "': " << gep.hex() << std::endl;
        gep = rerandomize_global(&gep, &mut rng);
        //std::cout << "global pseudonym for '" << id << "': " << gep.hex() << " (after randomize)" << std::endl;
        //gep = GlobalEncryptedPseudonym::FromHex(gep.hex());
        let mut lep = convert_to_local_pseudonym(&gep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        //lep = LocalEncryptedPseudonym::FromHex(lep.hex());
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << std::endl;
        lep = rerandomize_local(&lep, &mut rng);
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << " (after randomize)" << std::endl;

        let decryption_key = make_local_decryption_key(&secret_key, "very_secret_on_server", "login_session_of_user");
        let lp = decrypt_local_pseudonym(&lep, &decryption_key);
        //let expected = LocalPseudonym::from_hex("4854bb37a8f2e9555f317614290cbef72210901e05f0e0a6623e10df30dfa739");
        let hex = "be26a708fcf722db8d19f6d8c8443794156af30b17c44bcf4bb41791c0708945";
        let expected = decode_hex(hex).unwrap();
        //assert_eq!(lp.hex(), expected.hex());
        assert_eq!(&lp.encode()[..], &expected);
        //std::cout << "(decrypted local pseudonym) for '" << id << "': " << lp.hex() << std::endl;
        
        let gep = convert_from_local_pseudonym(&lep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        let mut lep = convert_to_local_pseudonym(&gep, "very_secret_on_server", "login_session_of_user", "access_group_of_user");
        //lep = LocalEncryptedPseudonym::FromHex(lep.hex());
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << std::endl;
        lep = rerandomize_local(&lep, &mut rng);
        //std::cout << "encrypted local pseudonym for '" << id << "': " << lep.hex() << " (after randomize)" << std::endl;

        let decryption_key = make_local_decryption_key(&secret_key, "very_secret_on_server", "login_session_of_user");
        let lp = decrypt_local_pseudonym(&lep, &decryption_key);
        //let expected = LocalPseudonym::from_hex("4854bb37a8f2e9555f317614290cbef72210901e05f0e0a6623e10df30dfa739");
        let hex = "be26a708fcf722db8d19f6d8c8443794156af30b17c44bcf4bb41791c0708945";
        let expected = decode_hex(hex).unwrap();
        //assert_eq!(lp.hex(), expected.hex());
        assert_eq!(&lp.encode()[..], &expected);
    }

    #[test]
    fn distributed_pep_api() {
        let n = 5;
        let mut rng = OsRng;

        let (global_public_key, global_secret_key) = generate_global_keys(&mut rng);

        let mut blinding_factors = Vec::new();
        for _ in 0..n {
            let blinding_factor = ScalarNonZero::random(&mut rng);
            blinding_factors.push(blinding_factor);
        }
        let blinded_global_secret_key = blinding_factors.iter().fold(global_secret_key, |acc, s| acc * s);

        let mut pseudonymisation_secrets = Vec::new();
        let mut rekeying_secrets = Vec::new();
        let mut systems = Vec::new();
        for i in 0..n {
            let system_id: SystemId = format!("system-{}", i);
            let pseudonymisation_secret = encode_hex(&ScalarNonZero::random(&mut rng).encode());
            pseudonymisation_secrets.push(pseudonymisation_secret.clone());
            let rekeying_secret = encode_hex(&ScalarNonZero::random(&mut rng).encode());
            rekeying_secrets.push(rekeying_secret.clone());
            let system = PEPSystem::new(system_id, PEPNetworkConfig::new(global_public_key, blinded_global_secret_key, (0..n).map(|i| format!("system-{}", i)).collect()), pseudonymisation_secret, rekeying_secret, blinding_factors[i]);
            systems.push(system);
        }

        fn pseudonymize_through_network(data_in: &GroupElement, pc_from: &Context, pc_to: &Context, dc: &Context, systems: &mut Vec<PEPSystem>, rng: &mut OsRng) -> GroupElement {
            let mut network = Vec::new();

            let msg_in = encrypt(&data_in, &systems[0].config.global_public_key, rng);

            // First system
            let proven = systems[0].pseudonymize(&msg_in, pc_from, pc_to, dc, rng);
            network.push((systems[0].system_id.clone(), msg_in.clone(), proven));

            // All other systems
            for i in 1..systems.len() {
                let system = &mut systems[i];
                let msg_in = system.verify_pseudonymize(&network, &pc_from, &pc_to, &dc).unwrap();
                let proven = system.pseudonymize(&msg_in, pc_from, pc_to, dc, rng);
                network.push((system.system_id.clone(), msg_in.clone(), proven));
            }

            // Recipient
            let msg_out = systems[0].verify_pseudonymize(&network, pc_from, pc_to, dc).unwrap(); // can be done by client
            let decryption_key = systems.iter().fold(systems[0].config.blinded_global_private_key, |acc, s| acc * s.decryption_key_part(dc));
            let data_out = decrypt(&msg_out, &decryption_key);
            data_out
        }

        fn transcrypt_through_network(data_in: &GroupElement, dc: &Context, systems: &mut Vec<PEPSystem>, rng: &mut OsRng) -> GroupElement {
            let mut network = Vec::new();

            let msg_in = encrypt(&data_in, &systems[0].config.global_public_key, rng);

            // First system
            let proven = systems[0].transcrypt(&msg_in, dc, rng);
            network.push((systems[0].system_id.clone(), msg_in.clone(), proven));

            // All other systems
            for i in 1..systems.len() {
                let system = &mut systems[i];
                let msg_in = system.verify_transcrypt(&network, &dc).unwrap();
                let proven = system.transcrypt(&msg_in, dc, rng);
                network.push((system.system_id.clone(), msg_in.clone(), proven));
            }

            // Recipient
            let msg_out = systems[0].verify_transcrypt(&network, dc).unwrap(); // can be done by client
            let decryption_key = systems.iter().fold(systems[0].config.blinded_global_private_key, |acc, s| acc * s.decryption_key_part(dc));
            let data_out = decrypt(&msg_out, &decryption_key);
            data_out
        }

        let pc_a: Context = Context::from("pc-user-a");
        let dc_a1: Context = Context::from("dc-user-a1");
        let pc_b: Context = Context::from("pc-user-b");
        let dc_b1: Context = Context::from("dc-user-b1");
        let dc_b2: Context = Context::from("dc-user-b2");
        let pc_c: Context = Context::from("pc-user-c");
        let dc_c1: Context = Context::from("dc-user-c1");

        let lp_a = GroupElement::random(&mut rng);
        let lp_b = pseudonymize_through_network(&lp_a, &pc_a, &pc_b, &dc_b1, &mut systems, &mut rng);
        let expected = decrypt(&(0..n).fold(encrypt(&lp_a, &global_public_key, &mut rng), |acc, i| rks(&acc, &make_decryption_factor(&rekeying_secrets[i], &dc_b1), &(make_pseudonymisation_factor(&pseudonymisation_secrets[i], &pc_a).invert() * make_pseudonymisation_factor(&pseudonymisation_secrets[i], &pc_b)))), &(0..n).fold(blinded_global_secret_key, |acc, i| acc * make_decryption_factor(&rekeying_secrets[i], &dc_b1) * &blinding_factors[i].invert()));
        assert_eq!(expected, lp_b);

        // Pseudonymization is invertible
        let lp_a_return = pseudonymize_through_network(&lp_b, &pc_b, &pc_a, &dc_a1, &mut systems, &mut rng);
        assert_eq!(lp_a, lp_a_return);

        // Pseudonymization is transitive
        let lp_c = pseudonymize_through_network(&lp_a, &pc_a, &pc_c, &dc_c1, &mut systems, &mut rng);
        let lp_c_via_b = pseudonymize_through_network(&lp_b, &pc_b, &pc_c, &dc_c1, &mut systems, &mut rng);
        assert_eq!(lp_c, lp_c_via_b);

        // Pseudonymization is deterministic for user
        let lp_b_2 = pseudonymize_through_network(&lp_a, &pc_a, &pc_b, &dc_b2, &mut systems, &mut rng);
        assert_eq!(lp_b, lp_b_2);
        assert_ne!(lp_b, lp_c);

        let plaintext_a = GroupElement::random(&mut rng);
        let plaintext_b = transcrypt_through_network(&plaintext_a, &dc_b1, &mut systems, &mut rng);
        assert_eq!(plaintext_a, plaintext_b);

        // Network is commutative
        systems.reverse();
        let lp_b_reversed = pseudonymize_through_network(&lp_a, &pc_a, &pc_b, &dc_b1, &mut systems, &mut rng);
        assert_eq!(lp_b, lp_b_reversed);
    }
}
